# ğŸ“˜ JavaScript: Literals vs Constructors, Boxing & Unboxing

> ğŸ—’ï¸ **Catatan pribadi** â€” Dokumentasi ini dibuat dari video tutorial tentang perbedaan literal dan constructor di JavaScript, lengkap dengan konsep boxing dan unboxing.

---

## ğŸ“š Daftar Isi

- [Pengenalan](#pengenalan)
- [String: Literal vs Constructor](#string-literal-vs-constructor)
- [Boxing â€” Literal Jadi Objek](#boxing)
- [Unboxing â€” Objek Balik Jadi Literal](#unboxing)
- [Constructor Property & instanceof](#constructor-property-dan-instanceof)
- [Tipe Data Lainnya](#tipe-data-lainnya)
- [Function Constructor](#function-constructor)
- [Object Constructor](#object-constructor)
- [Keyword `new` vs Tanpa `new`](#new-vs-tanpa-new)
- [Ringkasan](#ringkasan)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

Di JavaScript, ada **dua cara** untuk membuat nilai/data:

| Cara | Contoh | Hasil |
|---|---|---|
| **Literal** | `'Hello'` | Primitive type |
| **Constructor** | `new String('Hello')` | Object |

Keduanya bisa menyimpan data yang sama, tapi *di balik layar* cara kerjanya berbeda. Di sinilah konsep **boxing** dan **unboxing** masuk!

---

<a name="string-literal-vs-constructor"></a>
## ğŸ”¤ String: Literal vs Constructor

String adalah salah satu dari **tujuh tipe primitif** di JavaScript. Kita bisa membuatnya dengan dua cara:

```javascript
// Cara 1: String Literal (primitive)
const strLit = 'Hello';

// Cara 2: String Object via Constructor
const strObj = new String('Hello');
```

Sekarang coba kita lihat perbedaannya lewat `console.log`:

```javascript
console.log(strLit, typeof strLit);
// Output: Hello  string   â† ini primitive

console.log(strObj, typeof strObj);
// Output: String {'Hello'}  object   â† ini object, lengkap dengan index & length
```

> ğŸ’¡ **Intinya:** Literal menghasilkan tipe `string` (primitive). Constructor menghasilkan tipe `object` yang membungkus string di dalamnya.

---

<a name="boxing"></a>
## ğŸ“¦ Boxing â€” Literal Jadi Objek

Kalau kita punya **string literal** (primitive), mestinya kita tidak bisa memanggil method di atasnya â€” karena method itu milik object, bukan primitive.

Tapi ini bisa dilakukan:

```javascript
// Boxing terjadi di sini!
console.log(strLit.toUpperCase()); // "HELLO"
console.log(strLit[0]);            // "H"
```

**Kenapa bisa?** Karena JavaScript secara otomatis membungkus literal dengan wrapper object di balik layar â€” proses inilah yang disebut **boxing** ğŸ¥Š

```
strLit (primitive)  â†’  [boxing]  â†’  String Object  â†’  bisa pakai .toUpperCase()
```

Jadi walaupun `strLit` adalah primitive, setiap kali kita pakai method atau akses index, JavaScript diam-diam mengubahnya jadi object sementara, lalu kembali lagi.

---

<a name="unboxing"></a>
## ğŸ“¤ Unboxing â€” Objek Balik Jadi Literal

Kebalikan dari boxing adalah **unboxing** â€” mengambil nilai asli dari sebuah object dan mengubahnya kembali menjadi primitive.

Caranya pakai method `.valueOf()`:

```javascript
// Unboxing: dari object kembali ke primitive
console.log(strObj.valueOf(), typeof strObj.valueOf());
// Output: Hello  string
```

> ğŸ¤” **Tapi kok `.valueOf()` bisa dipakai?** Padahal method ini tidak kelihatan langsung di dalam object...

Jawabannya ada di **prototype chain**! Saat JavaScript mencari method di sebuah object, urutannya:
1. Cari langsung di object itu sendiri
2. Kalau tidak ada, cari di **prototype**-nya
3. Kalau masih tidak ada, cari di **prototype yang diwarisi** (inherited prototype)

Method `.valueOf()` ada di `Object.prototype` â€” yang diwarisi oleh semua object di JavaScript, termasuk String object. Selain `.valueOf()`, String prototype juga menyimpan method-method lain seperti `.slice()`, `.match()`, `.search()`, dll.

---

<a name="constructor-property-dan-instanceof"></a>
## ğŸ” Constructor Property & `instanceof`

### Constructor Property

Karena boxing bekerja di balik layar, bahkan **literal pun punya property `.constructor`**:

```javascript
console.log(strLit.constructor); // Æ’ String() { [native code] }
console.log(strObj.constructor); // Æ’ String() { [native code] }
```

Keduanya menunjukkan constructor yang sama â€” String.

### Operator `instanceof`

Operator `instanceof` mengecek apakah sesuatu adalah **instance dari constructor function**. Di sinilah literal dan object berbeda:

```javascript
// instanceof operator
console.log(strLit instanceof String); // false â† literal, bukan object
console.log(strObj instanceof String); // true  â† dibuat dengan new String()
```

> âš ï¸ **Perlu dicatat:** Literal mengembalikan `false` karena bukan object yang dibuat dengan `new`. Meski boxing terjadi di balik layar, secara teknis `strLit` tetaplah primitive.

---

<a name="tipe-data-lainnya"></a>
## ğŸ”¢ Tipe Data Lainnya

Konsep literal vs constructor ini tidak hanya berlaku untuk String. Mari lihat tipe lainnya:

### Number

```javascript
const numLit = 20;
const numObj = new Number(20);

console.log(numLit, typeof numLit); // 20  number   â† primitive
console.log(numObj, typeof numObj); // Number {20}  object   â† object
```

Sama seperti string, kalau kita pakai method seperti `.toFixed()` pada `numLit`, boxing akan terjadi otomatis.

### Boolean

```javascript
const boolLit = true;
const boolObj = new Boolean(true);

console.log(boolLit, typeof boolLit); // true  boolean   â† primitive
console.log(boolObj, typeof boolObj); // Boolean {true}  object   â† object
```

### Array

Array sedikit berbeda â€” **array bukan primitive**, array sudah merupakan object dari awal:

```javascript
const arrLit = [1, 2, 3, 4, 5];
const arrObj = new Array(1, 2, 3, 4, 5);

console.log(arrLit, typeof arrLit); // [1,2,3,4,5]  object
console.log(arrObj, typeof arrObj); // [1,2,3,4,5]  object
```

Makanya, baik pakai literal `[]` maupun constructor `new Array()`, hasilnya sama-sama bertipe `object`.

---

<a name="function-constructor"></a>
## âš™ï¸ Function Constructor

Ini bagian yang agak unik. Kita bisa membuat function dengan dua cara:

### Cara Biasa (Literal)

```javascript
const funcLit = function (x) {
  return x * x;
};

console.log(funcLit, typeof funcLit); // Æ’  function
console.log(funcLit(5));              // 25
```

### Pakai Function Constructor

```javascript
// Argumen pertama = nama parameter, argumen kedua = isi function (sebagai string!)
const funcObj = new Function('x', 'return x * x');

console.log(funcObj(3)); // 9
```

> ğŸ¤¯ Ini memang terlihat aneh â€” isi function ditulis sebagai **string**. Tapi hasilnya sama saja. Cara ini jarang dipakai dalam praktik sehari-hari, tapi penting untuk tahu bahwa function di JavaScript juga bisa dibuat dengan constructor.

Perlu diingat, `typeof funcLit` menghasilkan `"function"`, bukan `"object"` â€” meski function di JavaScript sebenarnya adalah object juga (tipe khusus dari object).

---

<a name="object-constructor"></a>
## ğŸ§± Object Constructor

Terakhir, mari lihat object biasa:

```javascript
const obj1 = {};                // Literal syntax
const obj2 = new Object();      // Constructor syntax

console.log(obj1, typeof obj1); // {}  object
console.log(obj2, typeof obj2); // {}  object
```

Keduanya identik! **Di balik layar**, ketika kita menulis `{}`, JavaScript sebenarnya melakukan `new Object()` secara otomatis. Jadi literal `{}` adalah shorthand dari constructor.

---

<a name="new-vs-tanpa-new"></a>
## âš¡ Keyword `new` vs Tanpa `new`

Ini adalah materi tambahan yang penting â€” karena ternyata `String()`, `Number()`, dan `Boolean()` bisa dipanggil **dengan atau tanpa keyword `new`**, dan hasilnya **berbeda**!

### String()

```javascript
const a = new String('Hello'); // pakai new â†’ menghasilkan Object
const b = String('Hello');     // tanpa new â†’ menghasilkan primitive string

console.log(typeof a); // "object"
console.log(typeof b); // "string"  â† sama seperti literal biasa 'Hello'
```

Jadi `String('Hello')` tanpa `new` itu fungsinya seperti **type conversion** â€” mengubah nilai apa pun menjadi string primitive, bukan membuat object baru.

```javascript
// Contoh konversi tipe dengan String()
console.log(String(123));       // "123"        â† number jadi string
console.log(String(true));      // "true"       â† boolean jadi string
console.log(String(null));      // "null"
console.log(String(undefined)); // "undefined"
```

---

### Number()

```javascript
const c = new Number(42); // pakai new â†’ menghasilkan Object
const d = Number(42);     // tanpa new â†’ menghasilkan primitive number

console.log(typeof c); // "object"
console.log(typeof d); // "number"
```

`Number()` tanpa `new` sangat berguna untuk **mengkonversi string atau nilai lain menjadi angka**:

```javascript
console.log(Number('99'));    // 99     â† string jadi number
console.log(Number('3.14')); // 3.14
console.log(Number(true));   // 1      â† true â†’ 1
console.log(Number(false));  // 0      â† false â†’ 0
console.log(Number(null));   // 0
console.log(Number('abc'));  // NaN    â† tidak bisa dikonversi
```

---

### Boolean()

```javascript
const e = new Boolean(false); // pakai new â†’ menghasilkan Object
const f = Boolean(false);     // tanpa new â†’ menghasilkan primitive boolean

console.log(typeof e); // "object"
console.log(typeof f); // "boolean"
```

`Boolean()` tanpa `new` dipakai untuk **mengecek apakah suatu nilai truthy atau falsy**:

```javascript
console.log(Boolean(0));         // false â† falsy
console.log(Boolean(''));        // false â† falsy
console.log(Boolean(null));      // false â† falsy
console.log(Boolean(undefined)); // false â† falsy
console.log(Boolean(NaN));       // false â† falsy

console.log(Boolean(1));         // true  â† truthy
console.log(Boolean('hello'));   // true  â† truthy
console.log(Boolean([]));        // true  â† truthy (array kosong pun truthy!)
console.log(Boolean({}));        // true  â† truthy (object kosong pun truthy!)
```

---

### âš ï¸ Jebakan `new Boolean()`

Ini salah satu gotcha yang paling sering bikin bingung pemula:

```javascript
const tricky = new Boolean(false); // ini adalah OBJECT, bukan boolean false

if (tricky) {
  console.log('Ini tereksekusi!'); // â† ini yang jalan!
} else {
  console.log('Ini tidak jalan');
}
```

**Kenapa?** Karena `tricky` adalah **object**, dan object apa pun (bahkan yang isinya `false`) dianggap **truthy** oleh JavaScript dalam kondisi `if`. Ini alasan kuat kenapa sebaiknya **hindari `new Boolean()`** dalam kondisi nyata.

---

### ğŸ—‚ï¸ Tabel Perbandingan Lengkap

| Penulisan | Hasil | typeof | Kegunaan |
|---|---|---|---|
| `'hello'` | primitive | `string` | Buat string biasa |
| `String('hello')` | primitive | `string` | Konversi nilai ke string |
| `new String('hello')` | object | `object` | Jarang dipakai |
| `42` | primitive | `number` | Buat number biasa |
| `Number('42')` | primitive | `number` | Konversi nilai ke number |
| `new Number(42)` | object | `object` | Jarang dipakai |
| `true` | primitive | `boolean` | Buat boolean biasa |
| `Boolean(0)` | primitive | `boolean` | Cek truthy/falsy |
| `new Boolean(true)` | object | `object` | âš ï¸ Hindari! Bikin bingung |

> ğŸ’¡ **Simpel saja:** Tanpa `new` = konversi ke primitive. Dengan `new` = buat object wrapper. Dalam praktik sehari-hari, **gunakan literal atau versi tanpa `new`** â€” lebih aman dan lebih mudah diprediksi.

---

<a name="ringkasan"></a>
## âœ… Ringkasan

| Tipe | Literal | Constructor | typeof Literal | typeof Constructor |
|---|---|---|---|---|
| String | `'hello'` | `new String('hello')` | `string` | `object` |
| Number | `20` | `new Number(20)` | `number` | `object` |
| Boolean | `true` | `new Boolean(true)` | `boolean` | `object` |
| Array | `[1,2,3]` | `new Array(1,2,3)` | `object` | `object` |
| Function | `function(){}` | `new Function(...)` | `function` | `function` |
| Object | `{}` | `new Object()` | `object` | `object` |

### Poin Kunci ğŸ”‘

- **Boxing** = JavaScript otomatis membungkus primitive literal menjadi object saat dibutuhkan (misalnya saat memanggil method)
- **Unboxing** = mengubah object kembali jadi primitive menggunakan `.valueOf()`
- `instanceof` akan mengembalikan `false` untuk literal dan `true` untuk object yang dibuat dengan `new`
- **`new String()`** = membuat object; **`String()`** tanpa `new` = konversi ke primitive string
- **`new Number()`** = membuat object; **`Number()`** tanpa `new` = konversi ke primitive number
- **`new Boolean()`** = membuat object (âš ï¸ selalu truthy!); **`Boolean()`** tanpa `new` = cek truthy/falsy
- Untuk sebagian besar kasus, gunakan **literal syntax** atau **versi tanpa `new`** â€” lebih aman dan mudah diprediksi!
