# ğŸ“˜ JavaScript: Literals vs Constructors, Boxing & Unboxing

> ğŸ—’ï¸ **Catatan pribadi** â€” Dokumentasi ini dibuat dari video tutorial tentang perbedaan literal dan constructor di JavaScript, lengkap dengan konsep boxing dan unboxing.

---

## ğŸ“š Daftar Isi

- [Pengenalan](#pengenalan)
- [String: Literal vs Constructor](#string-literal-vs-constructor)
- [Boxing â€” Literal Jadi Objek](#boxing)
- [Unboxing â€” Objek Balik Jadi Literal](#unboxing)
- [Constructor Property & instanceof](#constructor-property-dan-instanceof)
- [Tipe Data Lainnya](#tipe-data-lainnya)
- [Function Constructor](#function-constructor)
- [Object Constructor](#object-constructor)
- [Ringkasan](#ringkasan)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

Di JavaScript, ada **dua cara** untuk membuat nilai/data:

| Cara | Contoh | Hasil |
|---|---|---|
| **Literal** | `'Hello'` | Primitive type |
| **Constructor** | `new String('Hello')` | Object |

Keduanya bisa menyimpan data yang sama, tapi *di balik layar* cara kerjanya berbeda. Di sinilah konsep **boxing** dan **unboxing** masuk!

---

<a name="string-literal-vs-constructor"></a>
## ğŸ”¤ String: Literal vs Constructor

String adalah salah satu dari **tujuh tipe primitif** di JavaScript. Kita bisa membuatnya dengan dua cara:

```javascript
// Cara 1: String Literal (primitive)
const strLit = 'Hello';

// Cara 2: String Object via Constructor
const strObj = new String('Hello');
```

Sekarang coba kita lihat perbedaannya lewat `console.log`:

```javascript
console.log(strLit, typeof strLit);
// Output: Hello  string   â† ini primitive

console.log(strObj, typeof strObj);
// Output: String {'Hello'}  object   â† ini object, lengkap dengan index & length
```

> ğŸ’¡ **Intinya:** Literal menghasilkan tipe `string` (primitive). Constructor menghasilkan tipe `object` yang membungkus string di dalamnya.

---

<a name="boxing"></a>
## ğŸ“¦ Boxing â€” Literal Jadi Objek

Kalau kita punya **string literal** (primitive), mestinya kita tidak bisa memanggil method di atasnya â€” karena method itu milik object, bukan primitive.

Tapi ini bisa dilakukan:

```javascript
// Boxing terjadi di sini!
console.log(strLit.toUpperCase()); // "HELLO"
console.log(strLit[0]);            // "H"
```

**Kenapa bisa?** Karena JavaScript secara otomatis membungkus literal dengan wrapper object di balik layar â€” proses inilah yang disebut **boxing** ğŸ¥Š

```
strLit (primitive)  â†’  [boxing]  â†’  String Object  â†’  bisa pakai .toUpperCase()
```

Jadi walaupun `strLit` adalah primitive, setiap kali kita pakai method atau akses index, JavaScript diam-diam mengubahnya jadi object sementara, lalu kembali lagi.

---

<a name="unboxing"></a>
## ğŸ“¤ Unboxing â€” Objek Balik Jadi Literal

Kebalikan dari boxing adalah **unboxing** â€” mengambil nilai asli dari sebuah object dan mengubahnya kembali menjadi primitive.

Caranya pakai method `.valueOf()`:

```javascript
// Unboxing: dari object kembali ke primitive
console.log(strObj.valueOf(), typeof strObj.valueOf());
// Output: Hello  string
```

> ğŸ¤” **Tapi kok `.valueOf()` bisa dipakai?** Padahal method ini tidak kelihatan langsung di dalam object...

Jawabannya ada di **prototype chain**! Saat JavaScript mencari method di sebuah object, urutannya:
1. Cari langsung di object itu sendiri
2. Kalau tidak ada, cari di **prototype**-nya
3. Kalau masih tidak ada, cari di **prototype yang diwarisi** (inherited prototype)

Method `.valueOf()` ada di `Object.prototype` â€” yang diwarisi oleh semua object di JavaScript, termasuk String object. Selain `.valueOf()`, String prototype juga menyimpan method-method lain seperti `.slice()`, `.match()`, `.search()`, dll.

---

<a name="constructor-property-dan-instanceof"></a>
## ğŸ” Constructor Property & `instanceof`

### Constructor Property

Karena boxing bekerja di balik layar, bahkan **literal pun punya property `.constructor`**:

```javascript
console.log(strLit.constructor); // Æ’ String() { [native code] }
console.log(strObj.constructor); // Æ’ String() { [native code] }
```

Keduanya menunjukkan constructor yang sama â€” String.

### Operator `instanceof`

Operator `instanceof` mengecek apakah sesuatu adalah **instance dari constructor function**. Di sinilah literal dan object berbeda:

```javascript
// instanceof operator
console.log(strLit instanceof String); // false â† literal, bukan object
console.log(strObj instanceof String); // true  â† dibuat dengan new String()
```

> âš ï¸ **Perlu dicatat:** Literal mengembalikan `false` karena bukan object yang dibuat dengan `new`. Meski boxing terjadi di balik layar, secara teknis `strLit` tetaplah primitive.

---

<a name="tipe-data-lainnya"></a>
## ğŸ”¢ Tipe Data Lainnya

Konsep literal vs constructor ini tidak hanya berlaku untuk String. Mari lihat tipe lainnya:

### Number

```javascript
const numLit = 20;
const numObj = new Number(20);

console.log(numLit, typeof numLit); // 20  number   â† primitive
console.log(numObj, typeof numObj); // Number {20}  object   â† object
```

Sama seperti string, kalau kita pakai method seperti `.toFixed()` pada `numLit`, boxing akan terjadi otomatis.

### Boolean

```javascript
const boolLit = true;
const boolObj = new Boolean(true);

console.log(boolLit, typeof boolLit); // true  boolean   â† primitive
console.log(boolObj, typeof boolObj); // Boolean {true}  object   â† object
```

### Array

Array sedikit berbeda â€” **array bukan primitive**, array sudah merupakan object dari awal:

```javascript
const arrLit = [1, 2, 3, 4, 5];
const arrObj = new Array(1, 2, 3, 4, 5);

console.log(arrLit, typeof arrLit); // [1,2,3,4,5]  object
console.log(arrObj, typeof arrObj); // [1,2,3,4,5]  object
```

Makanya, baik pakai literal `[]` maupun constructor `new Array()`, hasilnya sama-sama bertipe `object`.

---

<a name="function-constructor"></a>
## âš™ï¸ Function Constructor

Ini bagian yang agak unik. Kita bisa membuat function dengan dua cara:

### Cara Biasa (Literal)

```javascript
const funcLit = function (x) {
  return x * x;
};

console.log(funcLit, typeof funcLit); // Æ’  function
console.log(funcLit(5));              // 25
```

### Pakai Function Constructor

```javascript
// Argumen pertama = nama parameter, argumen kedua = isi function (sebagai string!)
const funcObj = new Function('x', 'return x * x');

console.log(funcObj(3)); // 9
```

> ğŸ¤¯ Ini memang terlihat aneh â€” isi function ditulis sebagai **string**. Tapi hasilnya sama saja. Cara ini jarang dipakai dalam praktik sehari-hari, tapi penting untuk tahu bahwa function di JavaScript juga bisa dibuat dengan constructor.

Perlu diingat, `typeof funcLit` menghasilkan `"function"`, bukan `"object"` â€” meski function di JavaScript sebenarnya adalah object juga (tipe khusus dari object).

---

<a name="object-constructor"></a>
## ğŸ§± Object Constructor

Terakhir, mari lihat object biasa:

```javascript
const obj1 = {};                // Literal syntax
const obj2 = new Object();      // Constructor syntax

console.log(obj1, typeof obj1); // {}  object
console.log(obj2, typeof obj2); // {}  object
```

Keduanya identik! **Di balik layar**, ketika kita menulis `{}`, JavaScript sebenarnya melakukan `new Object()` secara otomatis. Jadi literal `{}` adalah shorthand dari constructor.

---

<a name="ringkasan"></a>
## âœ… Ringkasan

| Tipe | Literal | Constructor | typeof Literal | typeof Constructor |
|---|---|---|---|---|
| String | `'hello'` | `new String('hello')` | `string` | `object` |
| Number | `20` | `new Number(20)` | `number` | `object` |
| Boolean | `true` | `new Boolean(true)` | `boolean` | `object` |
| Array | `[1,2,3]` | `new Array(1,2,3)` | `object` | `object` |
| Function | `function(){}` | `new Function(...)` | `function` | `function` |
| Object | `{}` | `new Object()` | `object` | `object` |

### Poin Kunci ğŸ”‘

- **Boxing** = JavaScript otomatis membungkus primitive literal menjadi object saat dibutuhkan (misalnya saat memanggil method)
- **Unboxing** = mengubah object kembali jadi primitive menggunakan `.valueOf()`
- `instanceof` akan mengembalikan `false` untuk literal dan `true` untuk object yang dibuat dengan `new`
- Untuk sebagian besar kasus, gunakan **literal syntax** â€” lebih ringkas dan mudah dibaca!
