# ğŸ§© Object-Oriented Programming (OOP) di JavaScript

> ğŸ““ Dokumentasi pribadi ini dibuat dari video tutorial tentang OOP di JavaScript.
> Cocok banget buat kamu yang baru mulai belajar dan mau punya catatan yang enak dibaca!

---

## ğŸ“‹ Daftar Isi

- [Pengenalan OOP](#pengenalan)
- [Yang Sudah Kita Tahu Sebelumnya](#yang-sudah-kita-tahu)
- [Topik yang Akan Dipelajari](#topik-yang-akan-dipelajari)
  - [Object Literals](#object-literals)
  - [Constructor Functions](#constructor-functions)
  - [Prototypes & Prototype Chain](#prototypes--prototype-chain)
  - [Object.create & .call](#objectcreate--call)
  - [Classes (ES6)](#classes-es6)
  - [Inheritance & Subclasses](#inheritance--subclasses)
  - [Static Methods, Getters & Setters](#static-methods-getters--setters)
  - [Private Properties (ES2022)](#private-properties-es2022)
  - [Flags, Descriptors & Freezing](#flags-descriptors--freezing)
- [Proyek Akhir](#proyek-akhir)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan OOP

**Object-Oriented Programming (OOP)** adalah sebuah *paradigma pemrograman* â€” anggap saja ini sebagai cara atau gaya berpikir dalam menulis kode.

Di JavaScript, OOP sedikit unik karena **hampir semuanya adalah object**. Jadi kita sebenarnya sudah sering bersentuhan dengan konsep ini tanpa sadar!

---

<a name="yang-sudah-kita-tahu"></a>
## âœ… Yang Sudah Kita Tahu Sebelumnya

Sebelum masuk ke topik baru, kita sudah punya bekal yang cukup kuat:

| Konsep | Keterangan |
|--------|------------|
| ğŸ·ï¸ **Properties** | Atribut atau data yang dimiliki sebuah object |
| âš™ï¸ **Methods** | Fungsi yang ada di dalam sebuah object |
| ğŸ“¦ **Object Literals** | Cara paling dasar membuat object langsung di kode |

Kita sudah pernah bekerja dengan semuanya itu â€” sekarang saatnya kita gali lebih dalam!

---

<a name="topik-yang-akan-dipelajari"></a>
## ğŸ—ºï¸ Topik yang Akan Dipelajari

Berikut ini adalah peta jalan (roadmap) dari dua section ini. Santai saja, kita akan pelajari satu per satu!

---

<a name="object-literals"></a>
### ğŸ“¦ Object Literals

Kita akan lihat lagi cara membuat object secara langsung (literal), sekaligus memahami **keterbatasannya** â€” supaya kita tahu kapan perlu beralih ke cara yang lebih canggih.

Contoh sederhana object literal:

```js
// Membuat object secara langsung (object literal)
const person = {
  name: 'Budi',
  age: 25,
  greet: function() {
    console.log('Halo, nama saya ' + this.name);
  }
};

person.greet(); // Output: Halo, nama saya Budi
```

> âš ï¸ **Masalahnya:** Kalau kita butuh 100 object `person` yang berbeda-beda, kita harus nulis object literal sebanyak 100 kali. Tidak efisien!

---

<a name="constructor-functions"></a>
### ğŸ—ï¸ Constructor Functions

Ini solusi dari masalah di atas! Constructor function adalah seperti **blueprint (cetak biru)** yang bisa kita pakai berulang kali untuk membuat banyak object dengan struktur yang sama.

```js
// Constructor function = blueprint untuk membuat object
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.greet = function() {
    console.log('Halo, nama saya ' + this.name);
  };
}

// Membuat "instance" (objek nyata) dari blueprint
const budi = new Person('Budi', 25);
const sari = new Person('Sari', 30);

budi.greet(); // Output: Halo, nama saya Budi
sari.greet(); // Output: Halo, nama saya Sari
```

> ğŸ’¡ Kata kunci `new` memberi tahu JavaScript: *"Buat object baru menggunakan blueprint ini!"*

---

<a name="prototypes--prototype-chain"></a>
### ğŸ”— Prototypes & Prototype Chain

**Prototype** adalah object khusus yang menyimpan properties dan methods yang bisa di-*share* (digunakan bersama) oleh semua instance dari sebuah constructor.

Bayangkan prototype seperti "lemari komunal" â€” semua orang (semua instance) bisa mengakses isinya, tanpa harus punya salinan sendiri-sendiri.

**Prototype chain** adalah cara JavaScript menelusuri property/method dari satu level ke level berikutnya, seperti rantai yang saling terhubung.

```js
function Animal(name) {
  this.name = name;
}

// Tambahkan method ke prototype, bukan langsung ke constructor
// Ini lebih efisien karena semua instance berbagi satu fungsi yang sama
Animal.prototype.speak = function() {
  console.log(this.name + ' bersuara!');
};

const kucing = new Animal('Meong');
kucing.speak(); // Output: Meong bersuara!
```

---

<a name="objectcreate--call"></a>
### ğŸ› ï¸ Object.create & .call

Dua cara lain untuk bekerja dengan objects dan inheritance di JavaScript â€” `Object.create()` dan method `.call()`.

- **`Object.create()`** â†’ Membuat object baru dengan prototype tertentu yang sudah kita tentukan sendiri
- **`.call()`** â†’ Memanggil sebuah function dengan konteks `this` yang kita tentukan (berguna untuk berbagi constructor antar object)

---

<a name="classes-es6"></a>
### ğŸ›ï¸ Classes (ES6 / ES2015)

> ğŸ“Œ **Catatan penting:** Classes *bukan* bagian inti dari bahasa JavaScript. Ini adalah **sintaks baru** yang ditambahkan di **ES6 (ES2015)** untuk membuat OOP terasa lebih familiar dan mudah dibaca â€” terutama buat yang sudah biasa dengan bahasa lain seperti Java atau Python.

Di balik layar, JavaScript tetap menggunakan prototypes. Classes hanyalah "pembungkus" yang lebih cantik!

```js
// Cara lama: Constructor Function
function PersonOld(name, age) {
  this.name = name;
  this.age = age;
}

// Cara baru: Class Syntax (ES6)
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Halo, nama saya ${this.name} dan saya berumur ${this.age} tahun.`);
  }
}

const budi = new Person('Budi', 25);
budi.greet(); // Output: Halo, nama saya Budi dan saya berumur 25 tahun.
```

> âœ¨ Lebih bersih dan mudah dibaca, kan? Itulah keunggulan class syntax!

---

<a name="inheritance--subclasses"></a>
### ğŸ‘¨â€ğŸ‘§ Inheritance & Subclasses

**Inheritance (pewarisan)** memungkinkan sebuah class "mewarisi" properties dan methods dari class lain. Kita bisa membuat **subclass** yang merupakan versi lebih spesifik dari class induknya.

```js
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} bersuara.`);
  }
}

// Dog adalah subclass dari Animal
class Dog extends Animal {
  bark() {
    console.log(`${this.name} menggonggong: Guk guk!`);
  }
}

const rex = new Dog('Rex');
rex.speak(); // Diwarisi dari Animal â†’ Output: Rex bersuara.
rex.bark();  // Milik Dog sendiri â†’ Output: Rex menggonggong: Guk guk!
```

---

<a name="static-methods-getters--setters"></a>
### âš¡ Static Methods, Getters & Setters

- **Static methods** â†’ Method yang dipanggil langsung dari class-nya, bukan dari instance-nya
- **Getters** â†’ Cara membaca property dengan sintaks yang lebih rapi
- **Setters** â†’ Cara mengubah property dengan validasi jika diperlukan

```js
class Circle {
  constructor(radius) {
    this._radius = radius;
  }

  // Getter - akses seperti property biasa, tapi sebenarnya sebuah function
  get area() {
    return Math.PI * this._radius ** 2;
  }

  // Setter - bisa tambahkan validasi sebelum menyimpan nilai
  set radius(value) {
    if (value < 0) throw new Error('Radius tidak boleh negatif!');
    this._radius = value;
  }

  // Static method - dipanggil dari class langsung, bukan dari instance
  static describe() {
    console.log('Ini adalah class untuk menghitung lingkaran.');
  }
}

const c = new Circle(5);
console.log(c.area);      // Menggunakan getter
Circle.describe();         // Menggunakan static method
```

---

<a name="private-properties-es2022"></a>
### ğŸ”’ Private Properties (ES2022)

Dengan sintaks `#` yang baru (bagian dari **ES2022**), kita bisa membuat properties yang benar-benar **private** â€” artinya tidak bisa diakses dari luar class sama sekali.

```js
class BankAccount {
  // Property dengan # di depannya = PRIVATE
  #balance = 0;

  deposit(amount) {
    this.#balance += amount;
  }

  getBalance() {
    return this.#balance;
  }
}

const akun = new BankAccount();
akun.deposit(1000000);
console.log(akun.getBalance()); // 1000000 âœ…

// Ini akan ERROR! Property private tidak bisa diakses dari luar
// console.log(akun.#balance); // âŒ SyntaxError
```

> ğŸ›¡ï¸ Private properties berguna untuk **melindungi data sensitif** dan menjaga agar kode dalam class tidak bisa diubah sembarangan dari luar.

---

<a name="flags-descriptors--freezing"></a>
### ğŸš© Flags, Descriptors & Freezing

Kita juga akan belajar tentang:

- **Property Descriptors** â†’ Metadata tersembunyi di balik setiap property (apakah bisa diubah? bisa dihapus? bisa di-loop?)
- **Flags** â†’ Pengaturan seperti `writable`, `enumerable`, `configurable` untuk mengontrol perilaku property
- **Sealing & Freezing** â†’ Cara "mengunci" object agar tidak bisa dimodifikasi

```js
const obj = { nama: 'Budi' };

// Freeze = object tidak bisa diubah sama sekali
Object.freeze(obj);

obj.nama = 'Sari'; // Tidak akan berubah (dan tidak error di non-strict mode)
console.log(obj.nama); // Output: Budi (tetap tidak berubah)
```

---

<a name="proyek-akhir"></a>
## ğŸš€ Proyek Akhir

Setelah semua konsep di atas dipelajari, kita akan langsung praktek dengan **membuat sebuah proyek nyata** menggunakan pendekatan object-oriented â€” memanfaatkan classes, methods, dan semua yang sudah dipelajari sebelumnya.

Ini adalah bagian yang paling seru karena kita akan melihat semua konsep bekerja bersama-sama dalam satu proyek utuh! ğŸ‰

---

> ğŸ’¬ *"Di JavaScript, hampir semuanya adalah object â€” jadi mempelajari OOP berarti kamu semakin memahami cara JavaScript bekerja di level yang lebih dalam."*
