# ğŸ“š Dokumentasi Object-Oriented Programming (OOP) JavaScript untuk Pemula

---

## ğŸ“‘ Daftar Isi

- [Pengenalan](#pengenalan)
- [Apa itu Object-Oriented Programming (OOP)?](#apa-itu-oop)
- [Prinsip-Prinsip OOP](#prinsip-prinsip-oop)
- [Object Literals](#object-literals)
  - [Pengertian Object Literals](#pengertian-object-literals)
  - [Kelebihan dan Kekurangan](#kelebihan-dan-kekurangan)
- [Constructor Functions](#constructor-functions)
  - [Apa itu Constructor Functions?](#apa-itu-constructor-functions)
  - [Cara Kerja Constructor Functions](#cara-kerja-constructor-functions)
- [Prototypes](#prototypes)
  - [Pengertian Prototypes](#pengertian-prototypes)
  - [Prototype Chain & Inheritance](#prototype-chain-inheritance)
- [Object.create() Method](#object-create-method)
- [call() Method](#call-method)
- [Classes (ES6/ES2015)](#classes)
  - [Pengenalan Classes](#pengenalan-classes)
  - [Mengapa Menggunakan Classes?](#mengapa-classes)
- [Inheritance / Sub-classes](#inheritance-subclasses)
- [Static Methods](#static-methods)
- [Getters & Setters](#getters-setters)
- [Private Properties](#private-properties)
  - [Sintaks # (ES2022)](#sintaks-hash)
- [Flags & Descriptors](#flags-descriptors)
- [Sealing & Freezing](#sealing-freezing)
- [Kesimpulan](#kesimpulan)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

Selamat datang! ğŸ‘‹ Dalam dokumentasi ini, kita akan mempelajari **Object-Oriented Programming (OOP)** di JavaScript secara bertahap. 

> **ğŸ’¡ Catatan Penting:** Di JavaScript, hampir semuanya adalah objek! Kita sudah mengenal properties dan methods sebelumnya, sekarang kita akan mendalaminya lebih jauh.

Dokumentasi ini dibagi menjadi dua bagian besar yang akan membahas:
- âœ… Konsep dasar OOP
- âœ… Constructor functions dan prototypes
- âœ… Sintaks class modern (ES6+)
- âœ… Fitur-fitur advanced seperti private properties

Mari kita mulai! ğŸš€

---

<a name="apa-itu-oop"></a>
## ğŸ“– Apa itu Object-Oriented Programming (OOP)?

**Object-Oriented Programming (OOP)** adalah sebuah **paradigma pemrograman** atau cara/gaya dalam menulis kode program.

### ğŸ¤” Apa itu Paradigma Pemrograman?

Paradigma pemrograman adalah pendekatan atau metodologi yang kita gunakan untuk menyelesaikan masalah dalam pemrograman. Analoginya seperti:
- ğŸ¨ Melukis dengan cat air vs cat minyak (cara berbeda, hasil sama)
- ğŸ³ Masak dengan kompor gas vs kompor listrik (metode berbeda, makanan tetap matang)

### ğŸ¯ Inti dari OOP

Dalam OOP, kita mengorganisir kode dengan cara:
- Mengelompokkan data (properties) dan fungsi (methods) ke dalam **objek**
- Membuat blueprint (cetakan) untuk menciptakan banyak objek serupa
- Memanfaatkan konsep seperti inheritance (pewarisan) untuk menghindari pengulangan kode

### âš¡ Kenapa JavaScript Unik?

> **"With JavaScript, it's a little weird because just about everything is an object."**

Di JavaScript, hampir semua hal adalah objek:
- String, number, array = objek
- Function = objek
- Bahkan objek itu sendiri = objek! ğŸ˜„

---

<a name="prinsip-prinsip-oop"></a>
## ğŸ›ï¸ Prinsip-Prinsip OOP

OOP memiliki beberapa prinsip dasar yang akan kita pelajari:

1. **Encapsulation** (Enkapsulasi) ğŸ“¦
   - Membungkus data dan method dalam satu unit (objek)
   
2. **Abstraction** (Abstraksi) ğŸ­
   - Menyembunyikan detail kompleks, menampilkan yang penting saja
   
3. **Inheritance** (Pewarisan) ğŸ‘¨â€ğŸ‘¦
   - Membuat objek baru berdasarkan objek yang sudah ada
   
4. **Polymorphism** (Polimorfisme) ğŸª
   - Kemampuan objek untuk mengambil berbagai bentuk

> **ğŸ“Œ Catatan:** Kita akan mempelajari prinsip-prinsip ini secara bertahap melalui contoh-contoh praktis!

---

<a name="object-literals"></a>
## ğŸ“¦ Object Literals

<a name="pengertian-object-literals"></a>
### ğŸ” Pengertian Object Literals

**Object Literal** adalah cara paling sederhana untuk membuat objek di JavaScript.

> **"We already know a lot that we need to such as what are properties, what are methods. We've worked with object literals."**

**Contoh Object Literal:**

```javascript
// Membuat objek person dengan cara literal
const person = {
  // Properties (data)
  name: "John",
  age: 30,
  city: "Jakarta",
  
  // Method (fungsi)
  greet: function() {
    console.log(`Halo, nama saya ${this.name}`);
  }
};

// Menggunakan objek
console.log(person.name); // Output: John
person.greet(); // Output: Halo, nama saya John
```

### âœ¨ Karakteristik Object Literals

- Ditulis dengan kurung kurawal `{}`
- Berisi pasangan key-value
- Dibuat langsung tanpa blueprint
- Cocok untuk objek yang hanya dibuat sekali

<a name="kelebihan-dan-kekurangan"></a>
### âš–ï¸ Kelebihan dan Kekurangan

**âœ… Kelebihan:**
- Mudah dan cepat dibuat
- Sederhana untuk dipahami
- Cocok untuk objek tunggal

**âŒ Kekurangan:**
- Tidak efisien jika ingin membuat banyak objek serupa
- Harus menulis ulang kode untuk setiap objek baru
- Tidak ada blueprint yang bisa digunakan kembali

**Contoh Masalah:**

```javascript
// Membuat 3 objek person secara manual - tidak efisien! âŒ
const person1 = {
  name: "John",
  age: 30,
  greet: function() { console.log(`Halo, ${this.name}`); }
};

const person2 = {
  name: "Jane",
  age: 25,
  greet: function() { console.log(`Halo, ${this.name}`); }
};

const person3 = {
  name: "Bob",
  age: 35,
  greet: function() { console.log(`Halo, ${this.name}`); }
};

// Kode berulang! Butuh solusi yang lebih baik...
```

> **ğŸ’¡ Solusi:** Di sinilah **Constructor Functions** dan **Classes** berperan!

---

<a name="constructor-functions"></a>
## ğŸ—ï¸ Constructor Functions

<a name="apa-itu-constructor-functions"></a>
### ğŸ” Apa itu Constructor Functions?

**Constructor Function** adalah fungsi khusus yang digunakan sebagai **blueprint** (cetakan) untuk membuat banyak objek dengan struktur yang sama.

> **"Constructor functions which are like blueprints that we can create to be able to create multiple instances of objects."**

### ğŸ¯ Analogi Sederhana

Bayangkan constructor function seperti:
- ğŸª **Cetakan kue:** Satu cetakan bisa bikin banyak kue dengan bentuk sama
- ğŸ­ **Mesin pabrik:** Satu desain bisa produksi ribuan produk identik
- ğŸ“‹ **Template:** Satu template bisa bikin banyak dokumen dengan format sama

<a name="cara-kerja-constructor-functions"></a>
### âš™ï¸ Cara Kerja Constructor Functions

**Contoh Constructor Function:**

```javascript
// Constructor Function (huruf pertama KAPITAL - konvensi)
function Person(name, age, city) {
  // 'this' mengacu pada objek baru yang sedang dibuat
  this.name = name;
  this.age = age;
  this.city = city;
  
  this.greet = function() {
    console.log(`Halo, nama saya ${this.name}`);
  };
}

// Membuat BANYAK objek dari satu blueprint! âœ¨
const person1 = new Person("John", 30, "Jakarta");
const person2 = new Person("Jane", 25, "Bandung");
const person3 = new Person("Bob", 35, "Surabaya");

// Menggunakan objek
person1.greet(); // Output: Halo, nama saya John
person2.greet(); // Output: Halo, nama saya Jane
person3.greet(); // Output: Halo, nama saya Bob
```

### ğŸ”‘ Poin Penting

1. **Keyword `new`:** Harus menggunakan `new` untuk membuat instance baru
2. **Keyword `this`:** Merujuk pada objek yang sedang dibuat
3. **Konvensi Penamaan:** Nama constructor dimulai dengan huruf kapital (Person, Car, Book)
4. **Multiple Instances:** Bisa membuat banyak objek dari satu blueprint

### âœ… Keuntungan Constructor Functions

- Kode lebih efisien dan tidak berulang
- Mudah membuat banyak objek serupa
- Struktur yang konsisten
- Lebih terorganisir

---

<a name="prototypes"></a>
## ğŸ§¬ Prototypes

<a name="pengertian-prototypes"></a>
### ğŸ” Pengertian Prototypes

**Prototype** adalah objek khusus yang menyimpan properties dan methods yang dapat dibagikan ke semua instance objek.

> **"Prototypes which is a special type of object that holds properties and methods."**

### ğŸ¤” Mengapa Prototype Penting?

Tanpa prototype, setiap objek akan memiliki salinan method sendiri:

```javascript
// âŒ Tanpa Prototype - TIDAK EFISIEN!
function Person(name) {
  this.name = name;
  this.greet = function() {  // Setiap objek punya copy fungsi ini!
    console.log(`Halo ${this.name}`);
  };
}

const p1 = new Person("John");
const p2 = new Person("Jane");

// p1.greet dan p2.greet adalah fungsi BERBEDA di memory!
console.log(p1.greet === p2.greet); // false âŒ
```

**Dengan Prototype - EFISIEN! âœ…**

```javascript
function Person(name) {
  this.name = name;
  // Method TIDAK didefinisikan di sini
}

// Method disimpan di prototype (dibagi semua instance)
Person.prototype.greet = function() {
  console.log(`Halo ${this.name}`);
};

const p1 = new Person("John");
const p2 = new Person("Jane");

// p1.greet dan p2.greet adalah fungsi SAMA di memory!
console.log(p1.greet === p2.greet); // true âœ…

p1.greet(); // Output: Halo John
p2.greet(); // Output: Halo Jane
```

### ğŸ’¾ Keuntungan Prototype

- **Hemat Memory:** Method hanya disimpan sekali, dipakai berkali-kali
- **Efisiensi:** Lebih cepat dan ringan
- **Sharing:** Semua instance berbagi method yang sama

<a name="prototype-chain-inheritance"></a>
### ğŸ”— Prototype Chain & Inheritance

**Prototype Chain** adalah mekanisme JavaScript mencari property/method dari objek ke prototype-nya, terus naik hingga `Object.prototype`.

**Contoh Prototype Chain:**

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  console.log(`${this.name} sedang makan`);
};

function Dog(name, breed) {
  Animal.call(this, name); // Memanggil constructor parent
  this.breed = breed;
}

// Dog mewarisi dari Animal
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// Method khusus Dog
Dog.prototype.bark = function() {
  console.log(`${this.name} menggonggong: Woof!`);
};

const myDog = new Dog("Buddy", "Golden Retriever");

// Prototype chain bekerja:
myDog.bark(); // Method dari Dog.prototype âœ…
myDog.eat();  // Method dari Animal.prototype (inherited) âœ…
console.log(myDog.name); // Property dari instance âœ…
```

### ğŸ“Š Visualisasi Prototype Chain

```
myDog object
    â†“
Dog.prototype (bark method)
    â†“
Animal.prototype (eat method)
    â†“
Object.prototype (toString, valueOf, dll)
    â†“
null
```

> **ğŸ’¡ Penting:** JavaScript naik melalui chain ini sampai menemukan property/method yang dicari, atau sampai null.

---

<a name="object-create-method"></a>
## ğŸ”§ Object.create() Method

**`Object.create()`** adalah method untuk membuat objek baru dengan prototype yang ditentukan.

> **"Object create and call method."**

### ğŸ“ Sintaks Dasar

```javascript
const newObject = Object.create(prototypeObject);
```

### ğŸ¯ Contoh Penggunaan

```javascript
// Object prototype
const personPrototype = {
  greet: function() {
    console.log(`Halo, nama saya ${this.name}`);
  },
  
  introduce: function() {
    console.log(`Saya ${this.name}, umur ${this.age} tahun`);
  }
};

// Membuat objek dengan Object.create()
const person1 = Object.create(personPrototype);
person1.name = "John";
person1.age = 30;

const person2 = Object.create(personPrototype);
person2.name = "Jane";
person2.age = 25;

// Menggunakan method dari prototype
person1.greet(); // Output: Halo, nama saya John
person2.introduce(); // Output: Saya Jane, umur 25 tahun
```

### âœ¨ Keuntungan Object.create()

- Kontrol penuh atas prototype objek
- Lebih fleksibel dari constructor functions
- Cocok untuk inheritance patterns

---

<a name="call-method"></a>
## ğŸ“ call() Method

**`call()`** method memungkinkan kita memanggil fungsi dengan nilai `this` yang kita tentukan sendiri.

### ğŸ“ Sintaks Dasar

```javascript
functionName.call(thisValue, arg1, arg2, ...);
```

### ğŸ¯ Contoh Penggunaan

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

function Student(name, age, school) {
  // Memanggil constructor Person dengan 'this' dari Student
  Person.call(this, name, age);
  this.school = school;
}

const student1 = new Student("Alice", 20, "UI");
console.log(student1.name); // Output: Alice
console.log(student1.age); // Output: 20
console.log(student1.school); // Output: UI
```

### ğŸ’¡ Kapan Menggunakan call()?

- Untuk inheritance tanpa class syntax
- Meminjam method dari objek lain
- Mengatur konteks `this` secara eksplisit

---

<a name="classes"></a>
## ğŸ“ Classes (ES6/ES2015)

<a name="pengenalan-classes"></a>
### ğŸŒŸ Pengenalan Classes

**Classes** adalah sintaks modern (ES6/ES2015) untuk membuat objek dengan cara yang lebih mudah dibaca dan ditulis.

> **"Classes are actually not part of the core JavaScript language, but ES6 and or ES 2015 that update added classes as a syntax."**

### âš ï¸ Penting Dipahami!

Classes di JavaScript adalah **"syntactic sugar"** - cara menulis yang lebih manis/mudah untuk constructor functions dan prototypes. Di balik layar, tetap menggunakan prototype!

<a name="mengapa-classes"></a>
### âœ¨ Mengapa Menggunakan Classes?

> **"So we can actually use that to make things a little bit easier on ourselves."**

**Keuntungan Classes:**
- âœ… Sintaks lebih bersih dan mudah dibaca
- âœ… Mirip dengan bahasa OOP lain (Java, C++, Python)
- âœ… Lebih terorganisir dan maintainable
- âœ… Built-in support untuk inheritance

### ğŸ“ Contoh Class

**Cara Lama (Constructor Function):**

```javascript
// Constructor Function
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.greet = function() {
  console.log(`Halo, saya ${this.name}`);
};
```

**Cara Baru (Class Syntax):**

```javascript
// Class Syntax - Lebih bersih! âœ¨
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    console.log(`Halo, saya ${this.name}`);
  }
}

// Menggunakan class
const person1 = new Person("John", 30);
person1.greet(); // Output: Halo, saya John
```

### ğŸ”‘ Komponen Class

1. **Constructor:** Method khusus yang dipanggil saat membuat instance baru
2. **Methods:** Fungsi-fungsi yang tersedia untuk semua instance
3. **Properties:** Data yang disimpan dalam instance

---

<a name="inheritance-subclasses"></a>
## ğŸ‘¨â€ğŸ‘¦ Inheritance / Sub-classes

**Inheritance (Pewarisan)** memungkinkan class "anak" mewarisi properties dan methods dari class "induk".

### ğŸ“ Sintaks Dasar

```javascript
class ChildClass extends ParentClass {
  constructor(params) {
    super(parentParams); // Memanggil constructor parent
    // properties khusus child
  }
  
  // methods khusus child
}
```

### ğŸ¯ Contoh Sub-classes

```javascript
// Parent Class (Induk)
class Animal {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  eat() {
    console.log(`${this.name} sedang makan`);
  }
  
  sleep() {
    console.log(`${this.name} sedang tidur`);
  }
}

// Child Class (Anak) - mewarisi dari Animal
class Dog extends Animal {
  constructor(name, age, breed) {
    super(name, age); // Memanggil constructor Animal
    this.breed = breed; // Property tambahan khusus Dog
  }
  
  // Method tambahan khusus Dog
  bark() {
    console.log(`${this.name} menggonggong: Woof woof!`);
  }
  
  // Override method dari parent
  eat() {
    console.log(`${this.name} si ${this.breed} makan dog food`);
  }
}

// Menggunakan inheritance
const myDog = new Dog("Buddy", 3, "Golden Retriever");

myDog.bark(); // Method dari Dog âœ…
myDog.sleep(); // Method dari Animal (inherited) âœ…
myDog.eat(); // Method dari Dog (overridden) âœ…

console.log(myDog.name); // Property dari Animal âœ…
console.log(myDog.breed); // Property dari Dog âœ…
```

### ğŸ”‘ Keyword Penting

1. **`extends`:** Membuat class turunan dari class lain
2. **`super()`:** Memanggil constructor class induk
3. **Override:** Child class bisa menimpa method parent

### ğŸ’¡ Manfaat Inheritance

- Menghindari duplikasi kode
- Struktur hierarki yang jelas
- Reusability (penggunaan kembali) kode
- Mudah di-maintain dan di-extend

---

<a name="static-methods"></a>
## âš¡ Static Methods

**Static Methods** adalah method yang dipanggil pada class itu sendiri, **bukan** pada instance.

### ğŸ¯ Contoh Static Methods

```javascript
class MathHelper {
  // Static method
  static add(a, b) {
    return a + b;
  }
  
  static multiply(a, b) {
    return a * b;
  }
  
  static PI = 3.14159; // Static property
}

// Memanggil static method langsung dari class
console.log(MathHelper.add(5, 3)); // Output: 8
console.log(MathHelper.multiply(4, 2)); // Output: 8
console.log(MathHelper.PI); // Output: 3.14159

// âŒ TIDAK bisa dipanggil dari instance
const math = new MathHelper();
// math.add(5, 3); // Error! âŒ
```

### ğŸ“‹ Contoh Praktis

```javascript
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }
  
  // Regular method (dipanggil dari instance)
  greet() {
    console.log(`Halo, ${this.name}!`);
  }
  
  // Static method (utility function)
  static compareAge(user1, user2) {
    return user1.age - user2.age;
  }
  
  // Static method untuk create admin
  static createAdmin(name, email) {
    return new User(name, email, 'admin');
  }
}

const user1 = new User("John", "john@email.com");
user1.greet(); // âœ… Instance method

// Static method - dipanggil dari class
const admin = User.createAdmin("Admin", "admin@email.com"); // âœ…
```

### ğŸ’¡ Kapan Menggunakan Static Methods?

- Utility functions yang tidak perlu instance
- Factory methods (membuat instance dengan cara khusus)
- Helper functions yang berhubungan dengan class
- Konstanta atau konfigurasi class

---

<a name="getters-setters"></a>
## ğŸ›ï¸ Getters & Setters

**Getters** dan **Setters** adalah method khusus untuk mengakses dan mengubah properties dengan kontrol tambahan.

### ğŸ” Mengapa Perlu Getters & Setters?

- Validasi data sebelum di-set
- Enkapsulasi (menyembunyikan implementasi internal)
- Computed properties (property yang dihitung)
- Kontrol akses yang lebih baik

### ğŸ“ Sintaks

```javascript
class ClassName {
  // Getter - mengambil nilai
  get propertyName() {
    return this._propertyName;
  }
  
  // Setter - mengatur nilai
  set propertyName(value) {
    this._propertyName = value;
  }
}
```

### ğŸ¯ Contoh Getters & Setters

```javascript
class Person {
  constructor(firstName, lastName, age) {
    this._firstName = firstName;
    this._lastName = lastName;
    this._age = age;
  }
  
  // Getter - membaca seperti property biasa
  get fullName() {
    return `${this._firstName} ${this._lastName}`;
  }
  
  // Setter - menulis seperti property biasa
  set fullName(name) {
    const parts = name.split(' ');
    this._firstName = parts[0];
    this._lastName = parts[1];
  }
  
  // Getter dengan validasi
  get age() {
    return this._age;
  }
  
  // Setter dengan validasi
  set age(value) {
    if (value < 0 || value > 150) {
      console.log('Umur tidak valid!');
      return;
    }
    this._age = value;
  }
}

// Menggunakan getter & setter
const person = new Person("John", "Doe", 30);

// Getter - dipanggil seperti property
console.log(person.fullName); // Output: John Doe
console.log(person.age); // Output: 30

// Setter - diatur seperti property
person.fullName = "Jane Smith"; // Menggunakan setter
console.log(person._firstName); // Output: Jane
console.log(person._lastName); // Output: Smith

person.age = 25; // Menggunakan setter âœ…
person.age = -5; // Output: Umur tidak valid! âŒ
```

### âœ¨ Keuntungan Getters & Setters

1. **Validasi:** Cek data sebelum di-set
2. **Computed Properties:** Hitung nilai on-the-fly
3. **Enkapsulasi:** Sembunyikan property internal
4. **Backward Compatibility:** Bisa ubah implementasi tanpa ubah interface

---

<a name="private-properties"></a>
## ğŸ”’ Private Properties

**Private Properties** adalah properties yang hanya bisa diakses dari dalam class itu sendiri, tidak dari luar.

### ğŸ¯ Mengapa Private Properties?

- **Enkapsulasi:** Menyembunyikan detail implementasi
- **Keamanan:** Mencegah modifikasi tidak sengaja dari luar
- **Kontrol:** Hanya melalui method public yang kita tentukan

<a name="sintaks-hash"></a>
### # Sintaks # (ES2022)

JavaScript modern (ES2022) memperkenalkan sintaks `#` untuk membuat private properties.

> **"Including the very new number sign syntax which we can use to make certain properties private and that's part of the ES2022 standard."**

### ğŸ“ Contoh Private Properties

```javascript
class BankAccount {
  // Private properties (dimulai dengan #)
  #balance = 0;
  #accountNumber;
  #pin;
  
  constructor(accountNumber, initialBalance, pin) {
    this.#accountNumber = accountNumber;
    this.#balance = initialBalance;
    this.#pin = pin;
  }
  
  // Public method untuk akses private property
  getBalance() {
    return this.#balance;
  }
  
  // Private method
  #validatePin(inputPin) {
    return this.#pin === inputPin;
  }
  
  // Public method dengan validasi
  withdraw(amount, pin) {
    if (!this.#validatePin(pin)) {
      console.log('PIN salah!');
      return false;
    }
    
    if (amount > this.#balance) {
      console.log('Saldo tidak cukup!');
      return false;
    }
    
    this.#balance -= amount;
    console.log(`Berhasil tarik: Rp ${amount}`);
    return true;
  }
  
  deposit(amount) {
    if (amount <= 0) {
      console.log('Jumlah tidak valid!');
      return;
    }
    this.#balance += amount;
    console.log(`Berhasil setor: Rp ${amount}`);
  }
}

// Menggunakan class dengan private properties
const myAccount = new BankAccount('123456', 1000000, '1234');

// âœ… Akses melalui public method
console.log(myAccount.getBalance()); // Output: 1000000
myAccount.deposit(500000); // Output: Berhasil setor: Rp 500000
myAccount.withdraw(200000, '1234'); // Output: Berhasil tarik: Rp 200000

// âŒ Tidak bisa akses private property langsung
// console.log(myAccount.#balance); // SyntaxError! âŒ
// console.log(myAccount.#pin); // SyntaxError! âŒ
// myAccount.#validatePin('1234'); // SyntaxError! âŒ
```

### ğŸ” Cara Lama vs Cara Baru

**Cara Lama (Convention dengan _):**

```javascript
class OldWay {
  constructor() {
    this._privateProperty = 'value'; // Convention: _ berarti private
  }
  // Tapi tetap bisa diakses: obj._privateProperty âŒ
}
```

**Cara Baru (ES2022 dengan #):**

```javascript
class NewWay {
  #privateProperty = 'value'; // Benar-benar private! âœ…
  
  // HANYA bisa diakses dari dalam class
}
```

### âœ¨ Keuntungan Private Properties (#)

- **True Encapsulation:** Benar-benar tidak bisa diakses dari luar
- **Error Prevention:** Syntax error jika coba akses dari luar
- **Clear Intent:** Jelas mana yang public, mana yang private
- **Better Security:** Data sensitif lebih aman

---

<a name="flags-descriptors"></a>
## ğŸš© Flags & Descriptors

**Property Descriptors** adalah metadata yang mengontrol perilaku properties dalam objek.

### ğŸ” Apa itu Property Descriptors?

Setiap property dalam objek memiliki "flag" tersembunyi yang mengontrol:
- Apakah bisa diubah?
- Apakah muncul saat looping?
- Apakah bisa dihapus?

### ğŸ“ Flags yang Tersedia

1. **`writable`:** Apakah nilai bisa diubah? (true/false)
2. **`enumerable`:** Apakah muncul saat `for...in` loop? (true/false)
3. **`configurable`:** Apakah bisa dihapus atau diubah descriptor-nya? (true/false)
4. **`value`:** Nilai dari property

### ğŸ¯ Contoh Penggunaan

```javascript
const person = {
  name: 'John'
};

// Melihat property descriptor
const descriptor = Object.getOwnPropertyDescriptor(person, 'name');
console.log(descriptor);
/* Output:
{
  value: 'John',
  writable: true,
  enumerable: true,
  configurable: true
}
*/

// Mengatur property descriptor
Object.defineProperty(person, 'age', {
  value: 30,
  writable: false,    // Tidak bisa diubah
  enumerable: true,   // Muncul di loop
  configurable: false // Tidak bisa dihapus
});

console.log(person.age); // Output: 30

// Coba ubah (tidak akan berhasil karena writable: false)
person.age = 40;
console.log(person.age); // Output: masih 30 âŒ

// Coba hapus (tidak akan berhasil karena configurable: false)
delete person.age;
console.log(person.age); // Output: masih 30 âŒ
```

### ğŸ› ï¸ Method untuk Descriptors

```javascript
// Mendefinisikan property dengan descriptor
Object.defineProperty(obj, 'propertyName', {
  value: 'value',
  writable: true,
  enumerable: true,
  configurable: true
});

// Mendefinisikan banyak properties sekaligus
Object.defineProperties(obj, {
  prop1: { value: 'value1', writable: false },
  prop2: { value: 'value2', enumerable: false }
});

// Mendapatkan descriptor
Object.getOwnPropertyDescriptor(obj, 'propertyName');

// Mendapatkan semua descriptors
Object.getOwnPropertyDescriptors(obj);
```

### ğŸ’¡ Kapan Menggunakan?

- Membuat property constant (read-only)
- Menyembunyikan property dari enumeration
- Melindungi property dari penghapusan
- Fine-grained control atas properties

---

<a name="sealing-freezing"></a>
## â„ï¸ Sealing & Freezing

**Sealing** dan **Freezing** adalah cara untuk mengunci objek agar tidak bisa dimodifikasi.

### ğŸ”’ Object.seal()

**Sealing** mencegah penambahan dan penghapusan properties, tapi masih bisa mengubah nilai yang ada.

```javascript
const person = {
  name: 'John',
  age: 30
};

Object.seal(person);

// âœ… Bisa mengubah nilai property yang ada
person.name = 'Jane';
console.log(person.name); // Output: Jane

// âŒ Tidak bisa tambah property baru
person.city = 'Jakarta';
console.log(person.city); // Output: undefined

// âŒ Tidak bisa hapus property
delete person.age;
console.log(person.age); // Output: masih 30

// Cek apakah sealed
console.log(Object.isSealed(person)); // Output: true
```

### â„ï¸ Object.freeze()

**Freezing** mencegah SEMUA modifikasi: tidak bisa tambah, hapus, ATAU ubah nilai.

```javascript
const person = {
  name: 'John',
  age: 30
};

Object.freeze(person);

// âŒ Tidak bisa mengubah nilai
person.name = 'Jane';
console.log(person.name); // Output: masih John

// âŒ Tidak bisa tambah property
person.city = 'Jakarta';
console.log(person.city); // Output: undefined

// âŒ Tidak bisa hapus property
delete person.age;
console.log(person.age); // Output: masih 30

// Cek apakah frozen
console.log(Object.isFrozen(person)); // Output: true
```

### ğŸ“Š Perbandingan

| Operasi | Normal | Sealed | Frozen |
|---------|--------|--------|--------|
| Ubah nilai property | âœ… | âœ… | âŒ |
| Tambah property baru | âœ… | âŒ | âŒ |
| Hapus property | âœ… | âŒ | âŒ |

### ğŸ¯ Contoh Praktis

```javascript
// Konfigurasi aplikasi yang tidak boleh diubah
const CONFIG = {
  API_URL: 'https://api.example.com',
  API_KEY: 'secret-key-123',
  TIMEOUT: 5000
};

Object.freeze(CONFIG);

// Sekarang CONFIG tidak bisa dimodifikasi
// Cocok untuk konstanta dan konfigurasi penting

// Sealed untuk object yang struktur tetap, nilai bisa berubah
const userData = {
  name: '',
  email: '',
  age: 0
};

Object.seal(userData);

// Bisa update nilai, tapi tidak bisa tambah field baru
userData.name = 'John'; // âœ…
userData.address = 'Jakarta'; // âŒ Tidak bisa tambah
```

### âš ï¸ Catatan Penting

**Shallow vs Deep:**
- `seal()` dan `freeze()` hanya bekerja pada level pertama (shallow)
- Nested objects tidak terpengaruh
- Untuk deep freeze, perlu recursive function

```javascript
const obj = {
  name: 'John',
  address: {
    city: 'Jakarta'
  }
};

Object.freeze(obj);

// obj.name tidak bisa diubah âœ…
obj.name = 'Jane';
console.log(obj.name); // Output: masih John

// Tapi nested object masih bisa diubah! âš ï¸
obj.address.city = 'Bandung';
console.log(obj.address.city); // Output: Bandung âœ…
```

---

<a name="kesimpulan"></a>
## ğŸ“ Kesimpulan

Selamat! ğŸ‰ Kamu telah mempelajari konsep-konsep penting OOP di JavaScript:

### ğŸ“š Yang Telah Dipelajari

âœ… **Dasar OOP**
- Object literals dan kekurangannya
- Constructor functions sebagai blueprint
- Pentingnya prototypes untuk efisiensi

âœ… **Prototypes & Inheritance**
- Prototype chain
- Object.create() dan call() methods
- Pewarisan properties dan methods

âœ… **Class Syntax Modern**
- ES6 Classes (syntactic sugar)
- Inheritance dengan extends dan super
- Static methods untuk utility functions

âœ… **Advanced Features**
- Getters & Setters untuk kontrol akses
- Private properties dengan # (ES2022)
- Property descriptors dan flags
- Sealing & Freezing objects

### ğŸš€ Langkah Selanjutnya

> **"After that, I'd like to do some kind of project where we take an object-oriented approach and use classes and methods and so."**

Setelah mempelajari teori, saatnya **praktek**! ğŸ’ª

**Ide Project OOP:**
1. ğŸ® Game sederhana dengan classes (Player, Enemy, Game)
2. ğŸ›’ Shopping Cart dengan encapsulation
3. ğŸ“š Library Management System
4. ğŸ’° Bank Account Simulator
5. ğŸ‘¥ User Management System

### ğŸ’¡ Tips Belajar

1. **Practice, practice, practice!** ğŸ‹ï¸â€â™‚ï¸
   - Tulis ulang contoh dengan tangan
   - Modifikasi dan eksperimen
   
2. **Mulai dari yang sederhana** ğŸŒ±
   - Object literals â†’ Constructor â†’ Classes
   - Jangan langsung ke yang kompleks
   
3. **Pahami "Why" bukan hanya "How"** ğŸ¤”
   - Kenapa pakai prototype?
   - Kapan pakai private properties?
   
4. **Build real projects** ğŸ—ï¸
   - Teori + Praktek = Mahir!

### ğŸ¯ Ingat Selalu

- **OOP bukan silver bullet** - gunakan sesuai kebutuhan
- **Kesederhanaan > Kompleksitas** - jangan over-engineering
- **Konsistensi penting** - pilih satu style (constructor atau class) dan stick to it
- **Dokumentasi is king** - beri komentar untuk code kompleks

---

## ğŸ™ Penutup

Terima kasih telah belajar OOP JavaScript bersama dokumentasi ini! 

> **Remember:** Menjadi programmer handal butuh waktu dan konsistensi. Terus belajar, terus praktik! ğŸ’ª

**Happy Coding!** ğŸš€âœ¨

---

**ğŸ“Œ Dokumentasi ini dibuat untuk pembelajaran pribadi**

*Last updated: February 2026*
