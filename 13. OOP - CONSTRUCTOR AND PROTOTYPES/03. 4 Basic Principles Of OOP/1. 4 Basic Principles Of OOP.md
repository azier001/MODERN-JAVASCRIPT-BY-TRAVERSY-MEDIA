# ğŸ§± Empat Prinsip Dasar OOP (Object-Oriented Programming)

> ğŸ“ **Catatan:** Dokumentasi ini dibuat berdasarkan video tutorial tentang OOP. Cocok buat kamu yang baru mulai belajar konsep ini!

---

## ğŸ“‹ Daftar Isi

- [Pengenalan](#pengenalan)
- [1. Abstraction](#abstraction)
- [2. Encapsulation](#encapsulation)
- [3. Inheritance](#inheritance)
- [4. Polymorphism](#polymorphism)
- [Rangkuman](#rangkuman)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

Object-Oriented Programming (OOP) punya **4 prinsip dasar** yang perlu kamu pahami. Keempat prinsip ini bakal terus muncul saat kamu belajar OOP lebih dalam. Jadi, penting banget untuk ngerti dasar-dasarnya dulu sebelum masuk ke hal yang lebih kompleks.

Keempat prinsip itu adalah:
1. ğŸ” **Abstraction** â€” menyembunyikan detail yang tidak perlu
2. ğŸ“¦ **Encapsulation** â€” membungkus data dan method jadi satu unit
3. ğŸ‘ª **Inheritance** â€” mewarisi properti dan method dari kelas induk
4. ğŸ­ **Polymorphism** â€” satu method, banyak bentuk/perilaku

---

<a name="abstraction"></a>
## ğŸ” 1. Abstraction

**Definisi singkat:**
> Menyembunyikan semua bagian yang tidak relevan dari sebuah objek, untuk mengurangi kompleksitas dan meningkatkan efisiensi.

### ğŸš— Analogi: Mobil

Bayangin kamu nyetir mobil. Kamu nggak perlu tahu cara kerja fuel pump di dalam mesin, kan? Yang kamu butuhkan cuma tahu cara pakai **gas, rem, dan setir**. Detail teknisnya disembunyikan dari kamu sebagai pengguna â€” itulah **abstraction**.

### ğŸ’» Contoh di JavaScript

Saat kamu pakai `fetch()` atau `addEventListener()`, kamu nggak tahu cara kerjanya di balik layar. Kamu cukup tahu cara **menggunakannya** â€” gimana cara memanggilnya dan apa yang dikembalikan.

```js
// Kamu tinggal pakai fetch(), tanpa perlu tahu cara kerjanya di balik layar
fetch('https://api.example.com/data')
  .then(res => res.json())
  .then(data => console.log(data));
```

```js
// Sama dengan addEventListener â€” kamu cukup tahu cara pakainya
button.addEventListener('click', () => {
  console.log('Button diklik!');
});
```

### âœ… Manfaat Abstraction

- **Mengurangi kompleksitas** â€” kamu nggak perlu pusing sama detail internal
- **Mengurangi dampak perubahan** â€” kalau kamu tambah properti baru ke sebuah class, semua objek yang dibuat dari class itu otomatis dapat properti baru tanpa harus ubah kode di mana-mana

---

<a name="encapsulation"></a>
## ğŸ“¦ 2. Encapsulation

**Definisi singkat:**
> Proses membungkus (*wrapping*) data dan method ke dalam satu unit, seperti sebuah class. Biasanya juga melibatkan **data hiding** â€” menyembunyikan properti dari akses luar.

### ğŸ”’ Hubungan dengan Scope

Kamu sebetulnya sudah sering pakai konsep ini! Ingat **scope** di function? Kalau kamu bikin variabel di dalam function, variabel itu nggak bisa diakses dari luar â€” itu adalah encapsulation dalam bentuk sederhana.

### ğŸ’» Contoh: Class Circle dengan Private Property

Perhatikan kode berikut. Tanda `#` di depan nama properti artinya properti itu **private** â€” tidak bisa diakses dari luar class.

```js
class Circle {
  #radius; // properti private, ditandai dengan #

  constructor(value) {
    this.#radius = value;
  }

  get area() {
    // #radius bisa dipakai di DALAM class
    return Math.PI * Math.pow(this.#radius, 2);
  }
}
```

**Cara pakainya:**

```js
const c = new Circle(5);

// âœ… Ini boleh â€” akses lewat getter
console.log(c.area); // 78.53...

// âŒ Ini TIDAK boleh â€” langsung akses #radius dari luar
console.log(c.#radius); // Error!
```

> ğŸ’¡ **Getter** adalah method khusus yang dibuat supaya kamu bisa "mengintip" nilai private dari luar class, tapi tetap lewat jalur yang terkontrol.

---

<a name="inheritance"></a>
## ğŸ‘ª 3. Inheritance

**Definisi singkat:**
> Proses mewarisi properti dan method dari **parent class** (kelas induk) ke **child class** (kelas anak).

Ini adalah cara untuk **reuse code** dan mengurangi duplikasi. Daripada nulis ulang properti yang sama berkali-kali, kamu cukup buat class induk dan class-class lain bisa mewarisinya.

### ğŸ’» Contoh: Class User dan Admin

```js
// Class induk (parent)
class User {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

// Class anak (child) â€” mewarisi User dengan keyword `extends`
class Admin extends User {
  deleteUser(user) {
    users = users.filter((u) => u.name !== user.name);
  }
}
```

**Penjelasan:**
- `Admin` mewarisi **semua** properti dan method milik `User` (termasuk `name` dan `sayHello()`)
- `Admin` punya method tambahan sendiri yaitu `deleteUser()` yang nggak dimiliki oleh `User` biasa

```js
const admin = new Admin('Budi');
admin.sayHello();     // âœ… Diwarisi dari User â†’ "Hello, my name is Budi"
admin.deleteUser(someUser); // âœ… Method milik Admin sendiri

const user = new User('Ani');
user.deleteUser(someUser);  // âŒ Error! User biasa nggak punya method ini
```

---

<a name="polymorphism"></a>
## ğŸ­ 4. Polymorphism

**Definisi singkat:**
> Situasi di mana sesuatu bisa muncul dalam **banyak bentuk**. Dari kata Yunani: **poly** = banyak, **morph** = bentuk.

### ğŸ¤” Apa maksudnya?

Polymorphism memungkinkan kamu untuk menggunakan **nama method yang sama** di class yang berbeda-beda, tapi masing-masing class punya **implementasi yang berbeda**. Ini menggantikan kebutuhan akan deretan `if/else` atau `switch` yang panjang.

### ğŸ’» Contoh: Method `sayHello()` yang Berbeda

```js
class User {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

class Admin extends User {
  sayHello() {
    // Method yang SAMA tapi isinya BERBEDA
    console.log(`Hello, my name is ${this.name}. I am an admin.`);
  }
}
```

**Hasilnya:**

```js
const user = new User('Ani');
user.sayHello();  // â†’ "Hello, my name is Ani"

const admin = new Admin('Budi');
admin.sayHello(); // â†’ "Hello, my name is Budi. I am an admin."
```

Keduanya sama-sama punya method `sayHello()`, tapi perilakunya berbeda. Method `sayHello()` punya **banyak bentuk** â€” itulah polymorphism!

> ğŸ’¡ Kamu bisa punya 10, 20, bahkan 100 class yang semuanya punya method `sayHello()`, dan setiap class bisa mengimplementasikannya dengan cara berbeda.

---

<a name="rangkuman"></a>
## ğŸ“Œ Rangkuman

| # | Prinsip | Kata Kunci | Analogi Singkat |
|---|---------|------------|-----------------|
| 1 | ğŸ” **Abstraction** | Sembunyikan detail | Nyetir mobil tanpa tahu cara kerja mesin |
| 2 | ğŸ“¦ **Encapsulation** | Bungkus + lindungi data | Variabel di dalam function tidak bisa diakses dari luar |
| 3 | ğŸ‘ª **Inheritance** | Warisi dari induk | Anak mewarisi sifat orang tua |
| 4 | ğŸ­ **Polymorphism** | Satu nama, banyak bentuk | Tombol "print" di berbagai app â€” sama namanya, beda kerjanya |

---

> ğŸš€ **Selanjutnya:** Keempat prinsip ini akan makin jelas saat kamu mulai praktik langsung di video-video berikutnya. Jangan khawatir kalau sekarang masih ada yang terasa bingung â€” semuanya akan *klik* seiring waktu!
