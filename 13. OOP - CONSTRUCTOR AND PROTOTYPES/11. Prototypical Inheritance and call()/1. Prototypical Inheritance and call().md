# ğŸ§¬ Prototypical Inheritance di JavaScript

> ğŸ“ **Catatan:** Dokumentasi pribadi ini dibuat berdasarkan video tutorial tentang cara mengimplementasikan inheritance menggunakan constructor functions dan prototypes di JavaScript.

---

## ğŸ“š Daftar Isi

- [Pengenalan](#pengenalan)
- [Membuat Shape Constructor](#membuat-shape-constructor)
- [Membuat Constructor yang Mewarisi Shape](#membuat-constructor-yang-mewarisi-shape)
- [Mewarisi Prototype Methods](#mewarisi-prototype-methods)
- [Memperbaiki Constructor Property](#memperbaiki-constructor-property)
- [Polymorphism â€” Override Prototype Method](#polymorphism--override-prototype-method)
- [Catatan Penting](#catatan-penting)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

Sebelumnya kita sudah belajar bahwa setiap object punya prototype-nya sendiri, dan prototype itu bisa mewarisi prototype lain â€” inilah yang disebut **prototype chain**.

Misalnya:
- Object `Rectangle` punya prototypenya sendiri
- Tapi juga mewarisi `Object.prototype`
- Begitu juga dengan Array, yang punya prototype berisi method-method array, lalu mewarisi `Object.prototype`

Nah, di sini kita akan belajar cara bikin **object kita sendiri yang saling mewarisi satu sama lain**. Jadi bukan cuma mewarisi built-in prototype, tapi kita bikin hierarki inheritance sendiri.

> âš ï¸ **Perlu tahu:** Syntax inheritance pakai prototypes ini agak ribet dan banyak langkahnya. Di dunia nyata, kalau mau pakai OOP dengan inheritance, lebih disarankan pakai **ES6 Classes** yang jauh lebih bersih. Tapi penting untuk tahu cara kerjanya di balik layar!

---

<a name="membuat-shape-constructor"></a>
## ğŸ”· Membuat Shape Constructor

Kita mulai dengan membuat "induk" â€” yaitu constructor `Shape`. Ini adalah base dari semua shape yang akan kita buat.

```javascript
function Shape(name) {
  this.name = name;
}
```

Kenapa hanya `name`? Karena `name` adalah satu-satunya properti yang **dimiliki bersama** oleh semua shape. `Rectangle` punya `height` dan `width`, sedangkan `Circle` punya `radius` â€” jadi properti-properti spesifik itu tidak ditaruh di `Shape`.

---

<a name="membuat-constructor-yang-mewarisi-shape"></a>
## ğŸ”· Membuat Constructor yang Mewarisi Shape

Sekarang kita buat constructor `Rectangle` dan `Circle` yang mewarisi `Shape`.

### Rectangle

```javascript
function Rectangle(name, height, width) {
  Shape.call(this, name); // ğŸ‘ˆ mewarisi Shape

  this.height = height;
  this.width = width;
}
```

### Circle

```javascript
function Circle(name, radius) {
  Shape.call(this, name); // ğŸ‘ˆ mewarisi Shape

  this.radius = radius;
}
```

### ğŸ¤” Kenapa pakai `.call(this, name)`?

Di dalam `Shape`, kita nulis `this.name = name`. Nah, kalau kita panggil `Shape(name)` begitu saja, `this`-nya bakal merujuk ke **window object** (global), bukan ke instance yang sedang dibuat.

Dengan `Shape.call(this, name)`, kita bilang: *"Panggil fungsi `Shape`, tapi gunakan `this` yang ada di context sekarang"* â€” yaitu instance dari `Rectangle` atau `Circle` yang sedang dibuat.

### Membuat object-nya

```javascript
const rect = new Rectangle('Rectangle 1', 20, 20);
const cir  = new Circle('Circle 1', 30);

console.log(rect, cir);
// rect â†’ { name: 'Rectangle 1', height: 20, width: 20 }
// cir  â†’ { name: 'Circle 1', radius: 30 }
```

Kedua object sudah punya `name` dari `Shape`. âœ…

---

<a name="mewarisi-prototype-methods"></a>
## ğŸ”· Mewarisi Prototype Methods

Salah satu alasan utama pakai inheritance adalah supaya kita bisa **berbagi prototype methods**. Bayangkan kita taruh method di `Shape.prototype` â€” idealnya semua shape bisa akses method itu.

### Tambahkan method ke Shape.prototype

```javascript
Shape.prototype.logName = function () {
  console.log(`Shape Name: ${this.name}`);
};
```

### Masalahnya...

Kalau langsung coba `rect.logName()`, kita dapat **error**! Kenapa? Karena `Rectangle.prototype` belum "terhubung" ke `Shape.prototype`.

### Solusinya: `Object.create()`

```javascript
// Inherits Shape prototypes
Rectangle.prototype = Object.create(Shape.prototype);

// Inherits Shape prototypes
Circle.prototype = Object.create(Shape.prototype);
```

`Object.create(Shape.prototype)` membuat object baru yang prototype-nya adalah `Shape.prototype`. Jadi sekarang rantainya jadi:

```
rect â†’ Rectangle.prototype â†’ Shape.prototype â†’ Object.prototype
```

Sekarang `rect.logName()` dan `cir.logName()` bisa jalan! âœ…

---

<a name="memperbaiki-constructor-property"></a>
## ğŸ”· Memperbaiki Constructor Property

Ada satu masalah lagi. Setelah kita set `Rectangle.prototype = Object.create(Shape.prototype)`, kalau kita cek:

```javascript
console.log(rect.constructor); // â† ternyata menunjuk ke Shape, bukan Rectangle!
```

Ini terjadi karena kita "menimpa" prototype-nya, dan `constructor` property ikut kehilangan referensi yang benar.

### Solusinya: Set ulang constructor

```javascript
// Set prototype constructors
Rectangle.prototype.constructor = Rectangle;
Circle.prototype.constructor = Circle;
```

Sekarang `rect.constructor` sudah benar menunjuk ke `Rectangle`. âœ…

> âš ï¸ **Perhatian urutan:** Baris ini harus ditulis **setelah** `Object.create()`. Kalau ditulis sebelumnya, akan tertimpa lagi.

---

<a name="polymorphism--override-prototype-method"></a>
## ğŸ”· Polymorphism â€” Override Prototype Method

**Polymorphism** artinya method yang sama bisa **berperilaku berbeda** tergantung siapa yang memanggilnya.

Contohnya, kita mau `logName()` di `Rectangle` menampilkan teks yang berbeda dari `logName()` di `Shape`.

```javascript
// Override logName khusus untuk Rectangle
Rectangle.prototype.logName = function () {
  console.log(`Rectangle Name: ${this.name}`);
};
```

Sekarang:

```javascript
rect.logName(); // â†’ "Rectangle Name: Rectangle 1"
cir.logName();  // â†’ "Shape Name: Circle 1"  (masih pakai milik Shape)
```

`Rectangle` punya versi `logName`-nya sendiri, sementara `Circle` tetap pakai versi dari `Shape`. Inilah polymorphism! ğŸ‰

---

<a name="catatan-penting"></a>
## ğŸ“Œ Catatan Penting

### Kode Lengkap

```javascript
function Shape(name) {
  this.name = name;
}

Shape.prototype.logName = function () {
  console.log(`Shape Name: ${this.name}`);
};

function Rectangle(name, height, width) {
  Shape.call(this, name);
  this.height = height;
  this.width = width;
}

// Inherits Shape prototypes
Rectangle.prototype = Object.create(Shape.prototype);

// Override logName for Rectangle (polymorphism)
Rectangle.prototype.logName = function () {
  console.log(`Rectangle Name: ${this.name}`);
};

function Circle(name, radius) {
  Shape.call(this, name);
  this.radius = radius;
}

// Inherits Shape prototypes
Circle.prototype = Object.create(Shape.prototype);

// Set prototype constructors
Rectangle.prototype.constructor = Rectangle;
Circle.prototype.constructor = Circle;

const rect = new Rectangle('Rectangle 1', 20, 20);
const cir  = new Circle('Circle 1', 30);

rect.logName(); // "Rectangle Name: Rectangle 1"
cir.logName();  // "Shape Name: Circle 1"
```

### Checklist Langkah Inheritance dengan Prototypes

| Langkah | Yang Harus Dilakukan |
|---|---|
| 1 | Buat base constructor (contoh: `Shape`) |
| 2 | Panggil base constructor di child dengan `.call(this, ...)` |
| 3 | Set `Child.prototype = Object.create(Parent.prototype)` |
| 4 | Set ulang `Child.prototype.constructor = Child` |
| 5 | *(Opsional)* Override method di child untuk polymorphism |

> ğŸ’¡ **Ingat:** Cara ini cukup ribet. Kalau project besar dan butuh OOP dengan inheritance, lebih baik pakai **ES6 Classes** dengan keyword `extends` â€” jauh lebih simpel dan bersih!
