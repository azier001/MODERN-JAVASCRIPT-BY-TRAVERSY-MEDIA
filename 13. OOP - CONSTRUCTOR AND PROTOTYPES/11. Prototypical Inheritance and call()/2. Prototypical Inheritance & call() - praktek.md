# ğŸ§¬ Prototypal Inheritance di JavaScript

Dokumentasi belajar dari video tutorial â€” dibuat buat kamu yang baru mulai OOP di JavaScript!

---

## ğŸ“‘ Daftar Isi

- [Recap: Prototype Chain](#recap-prototype-chain)
- [Membuat Shape Constructor](#membuat-shape-constructor)
- [Rectangle Mewarisi Shape](#rectangle-mewarisi-shape)
- [Circle Mewarisi Shape](#circle-mewarisi-shape)
- [Mewarisi Prototype Methods](#mewarisi-prototype-methods)
- [Memperbaiki Constructor](#memperbaiki-constructor)
- [Polymorphism: Override Prototype Method](#polymorphism-override-prototype-method)
- [Kenapa Classes Lebih Enak?](#kenapa-classes-lebih-enak)

---

<a name="recap-prototype-chain"></a>
## ğŸ”— Recap: Prototype Chain

Sebelumnya kita sudah tahu bahwa setiap object di JavaScript punya **prototype**. Misalnya, object `Rectangle` punya prototypenya sendiri, tapi juga mewarisi `Object.prototype`. Begitu juga Array â€” punya prototype sendiri dengan berbagai method, lalu mewarisi `Object.prototype` di atasnya.

Rangkaian warisan ini disebut **prototype chain**. Nah, sekarang kita mau belajar gimana caranya **bikin inheritance sendiri** antar object buatan kita.

---

<a name="membuat-shape-constructor"></a>
## ğŸ—ï¸ Membuat Shape Constructor

Ide dasarnya: kita buat satu **constructor induk** bernama `Shape`, lalu shape-shape lain seperti `Rectangle` dan `Circle` akan mewarisi darinya.

Kenapa hanya `name` yang ada di `Shape`? Karena `height`, `width`, dan `radius` itu sifat spesifik masing-masing bentuk â€” tapi `name` dimiliki semua bentuk.

```javascript
function Shape(name) {
  this.name = name;
}
```

ğŸ’¡ **Apa yang terjadi di sini?**
- `function Shape(name)` â†’ ini adalah **constructor function**, bukan class biasa
- `this.name = name` â†’ setiap object yang dibuat dengan `Shape` akan punya property `name`

---

<a name="rectangle-mewarisi-shape"></a>
## ğŸ“ Rectangle Mewarisi Shape

Sekarang kita buat constructor `Rectangle` yang menerima `name`, `height`, dan `width`. Tapi kita **tidak mau nulis ulang** logika `name` â€” kita mau "pinjam" dari `Shape`.

**Langkah 1 â€” Buat constructor Rectangle:**

```javascript
function Rectangle(name, height, width) {
  this.height = height;
  this.width = width;
}
```

**Langkah 2 â€” Panggil Shape dengan `call()`:**

```javascript
function Rectangle(name, height, width) {
  Shape.call(this, name); // â† mewarisi property dari Shape

  this.height = height;
  this.width = width;
}
```

ğŸ’¡ **Apa yang terjadi di sini?**
- Kalau kita cuma tulis `Shape(name)`, maka `this` di dalam `Shape` akan menunjuk ke **window object** â€” bukan ke instance `Rectangle` yang sedang dibuat
- Dengan `Shape.call(this, name)`, kita bilang: *"Jalankan fungsi Shape, tapi gunakan `this` milik Rectangle"*
- Hasilnya: property `name` dari `Shape` ikut ter-assign ke object `Rectangle` kita

**Coba buat object Rectangle:**

```javascript
const rect = new Rectangle('Rectangle 1', 20, 20);
console.log(rect);
// Output: { name: 'Rectangle 1', height: 20, width: 20 }
```

---

<a name="circle-mewarisi-shape"></a>
## â­• Circle Mewarisi Shape

Sama seperti Rectangle, tapi `Circle` punya `radius` bukan `height` dan `width`.

```javascript
function Circle(name, radius) {
  Shape.call(this, name); // â† sama, mewarisi name dari Shape

  this.radius = radius;
}

const cir = new Circle('Circle 1', 30);
console.log(cir);
// Output: { name: 'Circle 1', radius: 30 }
```

ğŸ’¡ **Apa yang terjadi di sini?**
- Pola yang sama: `Shape.call(this, name)` untuk dapat property `name`
- Lalu `this.radius = radius` untuk property spesifik `Circle`

---

<a name="mewarisi-prototype-methods"></a>
## ğŸ§© Mewarisi Prototype Methods

Ini bagian yang paling penting! Salah satu alasan utama pakai inheritance adalah supaya kita bisa **tulis method sekali** di `Shape`, lalu semua shape lain bisa pakai method itu.

**Langkah 1 â€” Tambah method ke Shape.prototype:**

```javascript
Shape.prototype.logName = function () {
  console.log(`Shape Name: ${this.name}`);
};
```

**Langkah 2 â€” Coba panggil di Rectangle... hasilnya error! âŒ**

```javascript
rect.logName(); // â† ERROR! Rectangle belum tahu soal prototype Shape
```

**Langkah 3 â€” Hubungkan prototype Rectangle ke Shape:**

```javascript
// Inherits Shape prototypes
Rectangle.prototype = Object.create(Shape.prototype);
```

**Langkah 4 â€” Sekarang bisa dipakai! âœ…**

```javascript
rect.logName();
// Output: Shape Name: Rectangle 1
```

ğŸ’¡ **Apa yang terjadi di sini?**
- `Object.create(Shape.prototype)` â†’ membuat object baru yang **prototype-nya** adalah `Shape.prototype`
- Kita assign itu ke `Rectangle.prototype`, artinya sekarang Rectangle "tahu" semua method yang ada di Shape
- Kita pakai `Object.create()` dan **bukan** langsung `= Shape.prototype` supaya tidak nge-point ke referensi yang sama (bisa bermasalah kalau nanti diubah)

Hal yang sama perlu dilakukan untuk `Circle`:

```javascript
// Inherits Shape prototypes
Circle.prototype = Object.create(Shape.prototype);

cir.logName();
// Output: Shape Name: Circle 1
```

---

<a name="memperbaiki-constructor"></a>
## ğŸ”§ Memperbaiki Constructor

Ada efek samping dari langkah di atas. Setelah kita set `Rectangle.prototype = Object.create(Shape.prototype)`, kalau kita cek constructor-nya:

```javascript
console.log(rect.constructor);
// Output: Shape  â† harusnya Rectangle!
```

Ini tidak benar. Constructor dari `rect` seharusnya `Rectangle`, bukan `Shape`. Kita perlu **set ulang** constructor-nya:

```javascript
// Set prototype constructors
Rectangle.prototype.constructor = Rectangle;
Circle.prototype.constructor = Circle;
```

> âš ï¸ **Urutan penting!** Baris ini harus ditulis **setelah** `Object.create(...)`, bukan sebelumnya.

ğŸ’¡ **Apa yang terjadi di sini?**
- Saat kita assign `Rectangle.prototype = Object.create(Shape.prototype)`, property `constructor` ikut terganti ke `Shape`
- Jadi kita perlu manually set ulang: `Rectangle.prototype.constructor = Rectangle`
- Sekarang `rect.constructor` akan menampilkan fungsi `Rectangle` dengan benar âœ…

**Kode lengkap sampai sini:**

```javascript
function Shape(name) {
  this.name = name;
}

Shape.prototype.logName = function () {
  console.log(`Shape Name: ${this.name}`);
};

function Rectangle(name, height, width) {
  Shape.call(this, name);
  this.height = height;
  this.width = width;
}

Rectangle.prototype = Object.create(Shape.prototype); // Inherits Shape prototypes
Rectangle.prototype.constructor = Rectangle;          // Set prototype constructor

function Circle(name, radius) {
  Shape.call(this, name);
  this.radius = radius;
}

Circle.prototype = Object.create(Shape.prototype); // Inherits Shape prototypes
Circle.prototype.constructor = Circle;             // Set prototype constructor

const rect = new Rectangle('Rectangle 1', 20, 20);
const cir = new Circle('Circle 1', 30);

rect.logName(); // Shape Name: Rectangle 1
cir.logName();  // Shape Name: Circle 1
```

---

<a name="polymorphism-override-prototype-method"></a>
## ğŸ”„ Polymorphism: Override Prototype Method

**Polymorphism** = method yang **sama namanya tapi beda perilakunya** di object berbeda.

Misal, kita mau `logName` di `Rectangle` menampilkan teks yang berbeda dibanding `Shape`:

```javascript
// Override logName khusus untuk Rectangle
Rectangle.prototype.logName = function () {
  console.log(`Rectangle Name: ${this.name}`); // â† beda teksnya!
};
```

Sekarang:

```javascript
rect.logName(); // Rectangle Name: Rectangle 1  â† pakai versi Rectangle
cir.logName();  // Shape Name: Circle 1          â† masih pakai versi Shape
```

ğŸ’¡ **Apa yang terjadi di sini?**
- JavaScript akan **mencari method** dari yang paling dekat dulu (prototype Rectangle), baru naik ke prototype Shape
- Karena `Rectangle.prototype.logName` ada, dia dipakai â€” bukan yang dari `Shape`
- `Circle` tidak punya override, jadi dia tetap pakai `Shape.prototype.logName`
- Inilah **polymorphism**: method `logName` bisa melakukan hal yang berbeda tergantung object yang memanggilnya

---

<a name="kenapa-classes-lebih-enak"></a>
## ğŸ« Kenapa Classes Lebih Enak?

Seperti yang dibahas di video, syntax prototype inheritance ini agak **ribet dan banyak langkah**:

1. `Shape.call(this, name)` â€” untuk mewarisi properties
2. `Object.create(Shape.prototype)` â€” untuk mewarisi prototype methods
3. `Rectangle.prototype.constructor = Rectangle` â€” untuk memperbaiki constructor

Sedangkan dengan **ES6 Classes**, semua ini cukup ditulis:

```javascript
class Rectangle extends Shape {
  // extends otomatis handle semua 3 langkah di atas!
}
```

> ğŸ’¡ Video ini sengaja mengajarkan cara prototype dulu supaya kamu **paham apa yang sebenarnya terjadi di balik layar** ketika kamu pakai `class` dan `extends`. Di video berikutnya akan dibahas cara pakai Classes!
