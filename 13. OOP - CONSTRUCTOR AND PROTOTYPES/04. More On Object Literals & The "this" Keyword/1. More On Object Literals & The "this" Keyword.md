# ğŸ“¦ Object Literals & Keyword `this` dalam JavaScript

> ğŸ“ **Catatan:** Dokumentasi ini dibuat dari video tutorial tentang Object Literals dan penggunaan keyword `this` dalam JavaScript. Cocok banget buat kamu yang baru mulai belajar Object-Oriented Programming!

---

## ğŸ“‹ Daftar Isi

- [Pengenalan](#pengenalan)
- [Membuat Object Literal](#membuat-object-literal)
- [Menambahkan Method ke Object](#menambahkan-method-ke-object)
- [Keyword `this`](#keyword-this)
- [Keterbatasan Object Literal](#keterbatasan-object-literal)
- [Apa Selanjutnya?](#apa-selanjutnya)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

Di video ini, kita bahas lebih dalam soal **object literal** â€” sesuatu yang sebenernya udah sering kita pakai sepanjang belajar JavaScript. Selain itu, kita juga akan kenalan sama keyword `this`, yang penting banget di dunia pemrograman berorientasi objek (OOP).

Contoh yang akan dipakai di sini adalah **shapes** (bentuk geometri) seperti persegi panjang. Kenapa? Karena kita bisa melakukan sesuatu yang nyata, misalnya menghitung luas atau keliling â€” lebih seru daripada cuma `console.log("user registered")` ğŸ˜„

---

<a name="membuat-object-literal"></a>
## ğŸ§± Membuat Object Literal

**Object literal** adalah cara paling simpel untuk membuat objek di JavaScript. Formatnya pakai kurung kurawal `{}`, dan di dalamnya ada pasangan **key-value** yang disebut **properties**.

```javascript
const rectangle = {
  name: 'Rectangle 1',
  width: 20,
  height: 10,
};
```

Untuk mengakses properti dari sebuah objek, kita pakai **dot notation**:

```javascript
console.log(rectangle.name); // Output: Rectangle 1
```

Simpel kan? Tinggal tulis nama objeknya, titik, lalu nama propertinya.

---

<a name="menambahkan-method-ke-object"></a>
## âš™ï¸ Menambahkan Method ke Object

Selain properti biasa (angka, string), kita juga bisa menambahkan **function** ke dalam object. Function yang ada di dalam objek disebut **method**.

Di bawah ini kita tambahin method `area` untuk menghitung luas persegi panjang:

```javascript
const rectangle = {
  name: 'Rectangle 1',
  width: 20,
  height: 10,

  // Method untuk menghitung luas
  area: function () {
    return this.width * this.height;
  },
};
```

Untuk memanggil method-nya, sama seperti mengakses properti â€” pakai dot notation â€” **tapi ditambah tanda kurung `()`** karena ini adalah sebuah function:

```javascript
console.log(rectangle.area()); // Output: 200
```

> ğŸ’¡ **Ingat:** Method itu ya function, dan function harus dipanggil dengan `()`.

---

<a name="keyword-this"></a>
## ğŸ”‘ Keyword `this`

Perhatikan di dalam method `area` tadi, kita nulis `this.width` dan `this.height`. Nah, **`this` itu merujuk ke objek itu sendiri** â€” dalam hal ini, merujuk ke `rectangle`.

```javascript
area: function () {
  return this.width * this.height; // this = object rectangle
},
```

Jadi ketika kita panggil `rectangle.area()`, JavaScript tahu bahwa `this.width` berarti `rectangle.width` (nilainya 20) dan `this.height` berarti `rectangle.height` (nilainya 10).

### ğŸŒ `this` di Luar Object

Kalau kita pakai `this` di luar objek â€” misalnya langsung di global scope atau di dalam function biasa â€” `this` akan merujuk ke **`window` object** (di browser):

```javascript
// Di global scope
console.log(this); // Output: Window {...}

// Di dalam function biasa
function run() {
  console.log(this); // Output: Window {...} â€” tetap window!
}
run();
```

> âš ï¸ **Penting:** Di dalam context JavaScript, saat file pertama dijalankan, hal pertama yang dibuat adalah **window object**, dan `this` langsung di-assign ke sana. Itulah kenapa `this` di luar object selalu jadi window.

---

<a name="keterbatasan-object-literal"></a>
## ğŸš§ Keterbatasan Object Literal

Oke, sekarang bayangkan kita butuh **dua** persegi panjang yang berbeda. Kita harus bikin dua object literal terpisah:

```javascript
const rectangle = {
  name: 'Rectangle 1',
  width: 20,
  height: 10,
  area: function () {
    return this.width * this.height;
  },
};

const rectangle2 = {
  name: 'Rectangle 2',
  width: 30,
  height: 20,
  area: function () {
    return this.width * this.height;
  },
};

console.log(rectangle.area());  // Output: 200
console.log(rectangle2.area()); // Output: 600
```

Oke, masih bisa. Tapi... kalau butuh **100 persegi panjang**? Masa kita harus copy-paste 100 kali? ğŸ˜± Tentu tidak!

Di sinilah **keterbatasan object literal** terlihat jelas:

| Situasi | Object Literal |
|---|---|
| âœ… Butuh 1 objek saja | Cocok dipakai |
| âŒ Butuh banyak objek serupa | Tidak efisien |

---

<a name="apa-selanjutnya"></a>
## ğŸš€ Apa Selanjutnya?

Kalau kita butuh membuat banyak objek dengan struktur yang sama, kita perlu semacam **"blueprint"** atau cetakan. Di sinilah **Constructor Functions** dan **Classes** masuk!

Dengan constructor function atau class, kita bisa bikin blueprint sekali, lalu dari situ bisa dibuat banyak instance (contoh/turunan) dengan mudah. Itu yang akan dibahas di video berikutnya. Stay tuned! ğŸ‰

---

> ğŸ“Œ **Ringkasan Cepat:**
> - **Object literal** = cara membuat objek dengan `{}` dan key-value pairs
> - **Method** = function yang ada di dalam objek
> - **`this`** = merujuk ke objek itu sendiri (saat dipakai di dalam method)
> - **Keterbatasan** = object literal kurang efisien kalau perlu banyak objek yang mirip
> - **Solusinya** = Constructor Function / Class (materi berikutnya!)
