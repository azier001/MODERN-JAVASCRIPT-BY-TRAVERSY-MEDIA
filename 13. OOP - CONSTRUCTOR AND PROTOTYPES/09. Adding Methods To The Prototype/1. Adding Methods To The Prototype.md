# ğŸ§± JavaScript â€” Prototype Methods

> ğŸ“ **Catatan pribadi** dari video tutorial tentang cara menyimpan method di dalam prototype object.

---

## ğŸ“š Daftar Isi

- [Apa itu Prototype?](#apa-itu-prototype)
- [Memindahkan Method ke Prototype](#memindahkan-method-ke-prototype)
- [Menambah Lebih Banyak Method](#menambah-lebih-banyak-method)
- [Method dengan Parameter](#method-dengan-parameter)
- [Kenapa Pakai Prototype?](#kenapa-pakai-prototype)

---

<a name="apa-itu-prototype"></a>
## ğŸ” Apa itu Prototype?

Prototype itu kayak **wadah khusus** yang dimiliki setiap object di JavaScript. Di dalamnya bisa kita taruh method-method yang bisa dipakai oleh semua object yang dibuat dari constructor yang sama.

Kalau kita `console.log` sebuah object hasil constructor, di dalam bagian `[[Prototype]]`-nya bakal kelihatan apa saja yang tersimpan di sana. Awalnya cuma ada `constructor` function-nya.

```javascript
function Rectangle(name, width, height) {
  this.name = name;
  this.width = width;
  this.height = height;
}
```

> ğŸ’¡ Object `rect` punya properti `name`, `width`, dan `height` â€” tapi belum punya method apapun di dalam object itu sendiri.

---

<a name="memindahkan-method-ke-prototype"></a>
## ğŸšš Memindahkan Method ke Prototype

Daripada menulis method langsung di dalam constructor (yang artinya setiap object baru bakal bawa salinan method itu sendiri), lebih efisien kalau kita taruh method-nya di **prototype**.

Caranya: pakai pola `NamaConstructor.prototype.namaMethod = function() { ... }`

```javascript
// âœ… Method `area` disimpan di prototype, bukan di dalam constructor
Rectangle.prototype.area = function () {
  return this.width * this.height;
};
```

Sekarang kalau kita buat object baru dan panggil `.area()`, hasilnya tetap sama:

```javascript
const rect = new Rectangle('Rect', 10, 10);
console.log(rect.area()); // 100
```

> ğŸ” Bedanya: kalau kamu buka object `rect` di console, method `area` **tidak akan terlihat di dalam object itu langsung** â€” melainkan ada di bagian `[[Prototype]]`. Ini yang dimaksud lebih efisien!

---

<a name="menambah-lebih-banyak-method"></a>
## â• Menambah Lebih Banyak Method

Kita bisa terus menambah method sebanyak yang kita mau ke prototype yang sama.

```javascript
// Menghitung keliling
Rectangle.prototype.perimeter = function () {
  return 2 * (this.width + this.height);
};

// Mengecek apakah persegi (bukan persegi panjang)
Rectangle.prototype.isSquare = function () {
  return this.width === this.height;
};
```

Contoh pemakaian:

```javascript
const rect = new Rectangle('Rect', 10, 20);

console.log(rect.perimeter()); // 60  â†’ 2 * (10 + 20)
console.log(rect.isSquare());  // false â†’ 10 !== 20

const rect2 = new Rectangle('Rect 2', 10, 10);
console.log(rect2.isSquare()); // true â†’ 10 === 10
```

> ğŸ’¡ `isSquare` mengembalikan nilai `true` atau `false` karena kita pakai operator perbandingan `===`.

---

<a name="method-dengan-parameter"></a>
## ğŸ“¨ Method dengan Parameter

Method di prototype juga bisa menerima argumen seperti biasa.

```javascript
// Mengubah nama rectangle
Rectangle.prototype.changeName = function (newName) {
  this.name = newName;
};
```

Contoh pemakaian:

```javascript
const rect = new Rectangle('Rect', 10, 20);
rect.changeName('Test');
console.log(rect.name); // "Test"
```

> âš ï¸ Di dalam prototype method, kata kunci `this` tetap merujuk ke **object spesifik** yang memanggil method tersebut â€” bukan ke prototype-nya. Jadi `this.name` di atas berarti nama dari `rect` itu sendiri.

---

<a name="kenapa-pakai-prototype"></a>
## ğŸ¯ Kenapa Pakai Prototype?

Karena **semua object** yang dibuat dari constructor yang sama otomatis punya akses ke method-method di prototype tersebut â€” tanpa perlu mendefinisikannya ulang.

```javascript
const rect  = new Rectangle('Rect 1', 10, 10);
const rect2 = new Rectangle('Rect 2', 30, 40);

console.log(rect.area());  // 100
console.log(rect2.area()); // 1200
```

Kedua object â€” `rect` dan `rect2` â€” bisa pakai `.area()` yang sama, karena keduanya dibuat dari constructor `Rectangle` yang prototype-nya sudah kita isi method tersebut.

> ğŸ§  **Analogi:** Bayangkan prototype seperti buku resep bersama. Semua koki (object) yang bekerja di dapur yang sama (constructor) bisa pakai resep (method) yang ada di buku itu â€” tanpa masing-masing harus bawa buku resep sendiri.

---

### ğŸ“¦ Kode Lengkap

```javascript
function Rectangle(name, width, height) {
  this.name = name;
  this.width = width;
  this.height = height;
}

Rectangle.prototype.area = function () {
  return this.width * this.height;
};

Rectangle.prototype.perimeter = function () {
  return 2 * (this.width + this.height);
};

Rectangle.prototype.isSquare = function () {
  return this.width === this.height;
};

Rectangle.prototype.changeName = function (newName) {
  this.name = newName;
};

const rect  = new Rectangle('Rect', 10, 20);
const rect2 = new Rectangle('Rect 2', 30, 40);

console.log(rect.area());       // 200
console.log(rect.perimeter());  // 60
console.log(rect.isSquare());   // false

rect.changeName('Test');
console.log(rect.name);         // "Test"

console.log(rect2.area());      // 1200
```
