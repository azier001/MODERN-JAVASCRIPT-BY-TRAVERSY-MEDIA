# ğŸ“š Dokumentasi: Dari Callback Hell ke Promises

> ğŸ“ **Panduan Lengkap untuk Pemula**  
> Belajar cara mengubah callback hell menjadi promises dengan JavaScript

---

## ğŸ“‘ Daftar Isi

- [Pengenalan](#pengenalan)
- [Persiapan Awal](#persiapan-awal)
- [Apa itu Callback Hell?](#apa-itu-callback-hell)
- [Membuat File HTML](#membuat-file-html)
- [Kode Awal: Callback Hell](#kode-awal-callback-hell)
- [Memahami Masalah Callback Hell](#memahami-masalah-callback-hell)
- [Mulai Refactoring ke Promises](#mulai-refactoring-ke-promises)
  - [Langkah 1: Hapus Parameter Callback](#langkah-1-hapus-parameter-callback)
  - [Langkah 2: Return Promise](#langkah-2-return-promise)
  - [Langkah 3: Tambah Resolve & Reject](#langkah-3-tambah-resolve-reject)
  - [Langkah 4: Perbaiki Status Check](#langkah-4-perbaiki-status-check)
  - [Langkah 5: Ganti Callback dengan Resolve](#langkah-5-ganti-callback-dengan-resolve)
- [Menggunakan Promise dengan .then()](#menggunakan-promise-dengan-then)
- [Promise Chaining](#promise-chaining)
- [Error Handling dengan .catch()](#error-handling-dengan-catch)
- [Kode Final](#kode-final)
- [Kesimpulan](#kesimpulan)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

Dalam tutorial ini, kita akan belajar cara mengubah kode JavaScript yang menggunakan **callback hell** (banyak callback bersarang) menjadi kode yang lebih bersih menggunakan **Promises**.

### ğŸ¬ Apa yang akan kita pelajari?

âœ… Memahami masalah callback hell  
âœ… Membuat function yang mengembalikan Promise  
âœ… Menggunakan `.then()` untuk promise chaining  
âœ… Menangani error dengan `.catch()`  

---

<a name="persiapan-awal"></a>
## ğŸ› ï¸ Persiapan Awal

Sebelum memulai, pastikan kamu punya:

1. **Text Editor** (VS Code, Sublime Text, atau editor apapun)
2. **Browser** (Chrome, Firefox, dll)
3. **3 File JSON** dalam folder yang sama:
   - `movies.json`
   - `actors.json`
   - `directors.json`

> ğŸ’¡ **Tips**: Buat folder baru untuk project ini agar file-file tertata rapi!

---

<a name="apa-itu-callback-hell"></a>
## ğŸ˜± Apa itu Callback Hell?

**Callback Hell** adalah kondisi dimana kita memiliki banyak callback function yang bersarang (nested), membentuk pola seperti segitiga atau piramida.

**Contoh Callback Hell:**

```javascript
getData('./movies.json', (data) => {
  console.log(data);
  getData('./actors.json', (data) => {
    console.log(data);
    getData('./directors.json', (data) => {
      console.log(data);
    });
  });
});
```

### âš ï¸ Masalahnya:

- âŒ Susah dibaca
- âŒ Susah di-maintain
- âŒ Membentuk "segitiga" ke kanan
- âŒ Semakin banyak callback, semakin dalam pola segitiganya

---

<a name="membuat-file-html"></a>
## ğŸ“„ Membuat File HTML

**Langkah 1:** Buat file `index.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Promises vs Callback Hell</title>
  </head>
  <body>
    <h1>Promises vs Callback Hell</h1>

    <script src="./script.js"></script>
  </body>
</html>
```

> ğŸ“ **Catatan**: File ini sederhana, hanya meload `script.js` kita

---

<a name="kode-awal-callback-hell"></a>
## ğŸ”´ Kode Awal: Callback Hell

**Langkah 2:** Buat file `script.js` dengan kode berikut:

```javascript
function getData(endpoint, cb) {
  const xhr = new XMLHttpRequest();

  xhr.open('GET', endpoint);

  xhr.onreadystatechange = function () {
    if ((this.readyState === 4) & (this.status === 200)) {
      cb(JSON.parse(this.responseText));
    }
  };

  setTimeout(() => {
    xhr.send();
  }, Math.floor(Math.random() * 3000) + 1000);
}

getData('./movies.json', (data) => {
  console.log(data);
  getData('./actors.json', (data) => {
    console.log(data);
    getData('./directors.json', (data) => {
      console.log(data);
    });
  });
});
```

### ğŸ” Penjelasan Kode:

- **`getData(endpoint, cb)`**: Function yang menerima 2 parameter
  - `endpoint`: URL file JSON
  - `cb`: Callback function yang dipanggil saat data selesai diambil
  
- **`XMLHttpRequest`**: API untuk melakukan HTTP request

- **`setTimeout`**: Mensimulasikan delay 1-4 detik (random)

- **Nested Callbacks**: Setiap `getData` dipanggil di dalam callback sebelumnya â†’ **Callback Hell!** ğŸ˜±

---

<a name="memahami-masalah-callback-hell"></a>
## ğŸ¤” Memahami Masalah Callback Hell

Coba perhatikan struktur kode di atas:

```
getData() {
  callback {
    getData() {
      callback {
        getData() {
          callback {
            // ... semakin dalam!
          }
        }
      }
    }
  }
}
```

**Masalah utama:**

1. ğŸ“ **Berbentuk Segitiga** - Kode bergerak ke kanan
2. ğŸ”„ **Sulit Membaca** - Harus mengikuti alur nested
3. ğŸ› **Sulit Debug** - Error handling menjadi kompleks

**Solusinya?** â†’ **PROMISES!** âœ¨

---

<a name="mulai-refactoring-ke-promises"></a>
## ğŸ”„ Mulai Refactoring ke Promises

Sekarang kita akan mengubah kode callback hell menjadi promises **langkah demi langkah**.

---

<a name="langkah-1-hapus-parameter-callback"></a>
### ğŸ“ Langkah 1: Hapus Parameter Callback

**Dari:**
```javascript
function getData(endpoint, cb) {
```

**Menjadi:**
```javascript
function getData(endpoint) {
```

> âœ‚ï¸ **Kenapa?** Karena kita tidak akan menggunakan callback lagi, melainkan Promise!

---

<a name="langkah-2-return-promise"></a>
### ğŸ“ Langkah 2: Return Promise

Tambahkan `return new Promise()` dan wrap semua kode di dalamnya:

```javascript
function getData(endpoint) {
  return new Promise((resolve, reject) => {
    // Semua kode akan masuk ke sini
  });
}
```

> ğŸ **Penjelasan**: 
> - `new Promise()` membuat promise baru
> - Menerima function dengan 2 parameter: `resolve` dan `reject`
> - `resolve`: dipanggil saat berhasil
> - `reject`: dipanggil saat ada error

---

<a name="langkah-3-tambah-resolve-reject"></a>
### ğŸ“ Langkah 3: Tambah Resolve & Reject

Pindahkan semua kode XMLHttpRequest ke dalam Promise:

```javascript
function getData(endpoint) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();

    xhr.open('GET', endpoint);

    xhr.onreadystatechange = function () {
      if (this.readyState === 4 && this.status === 200) {
        // Nanti kita akan ubah bagian ini
        cb(JSON.parse(this.responseText));
      }
    };

    setTimeout(() => {
      xhr.send();
    }, Math.floor(Math.random() * 3000) + 1000);
  });
}
```

---

<a name="langkah-4-perbaiki-status-check"></a>
### ğŸ“ Langkah 4: Perbaiki Status Check

Kita perlu memisahkan pengecekan `readyState` dan `status` agar bisa handle error:

**Dari:**
```javascript
if (this.readyState === 4 && this.status === 200) {
  cb(JSON.parse(this.responseText));
}
```

**Menjadi:**
```javascript
if (this.readyState === 4) {
  if (this.status === 200) {
    // Berhasil - nanti pakai resolve
    cb(JSON.parse(this.responseText));
  } else {
    // Gagal - nanti pakai reject
    reject('Something went wrong');
  }
}
```

> âš ï¸ **Penting!** 
> - Kita tidak bisa pakai `else` untuk `readyState` karena nilainya berubah dari 1, 2, 3, hingga 4
> - Jika pakai `else` langsung, akan selalu jalan bahkan saat masih loading

---

<a name="langkah-5-ganti-callback-dengan-resolve"></a>
### ğŸ“ Langkah 5: Ganti Callback dengan Resolve

Sekarang ganti `cb()` dengan `resolve()`:

```javascript
function getData(endpoint) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();

    xhr.open('GET', endpoint);

    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(JSON.parse(this.responseText)); // âœ… Pakai resolve
        } else {
          reject('Something went wrong'); // âœ… Pakai reject
        }
      }
    };

    setTimeout(() => {
      xhr.send();
    }, Math.floor(Math.random() * 3000) + 1000);
  });
}
```

> ğŸ‰ **Selamat!** Function `getData` sekarang mengembalikan Promise!

---

<a name="menggunakan-promise-dengan-then"></a>
## âœ¨ Menggunakan Promise dengan .then()

Sekarang kita ubah cara memanggil function tersebut. Hapus kode callback hell yang lama!

**Langkah 1:** Panggil `getData` dengan `.then()`

```javascript
getData('./movies.json')
  .then((movies) => {
    console.log(movies);
  });
```

### ğŸ” Penjelasan:

- `getData('./movies.json')` â†’ memanggil function, return Promise
- `.then((movies) => {...})` â†’ akan jalan saat promise berhasil (resolved)
- `movies` â†’ data yang kita `resolve()` dari dalam Promise

**Test di browser!** Buka console, kamu akan melihat data movies setelah 1-4 detik! ğŸ¬

---

<a name="promise-chaining"></a>
## â›“ï¸ Promise Chaining

Sekarang bagian menariknya! Kita akan "chain" (menghubungkan) beberapa promise.

### ğŸ“ Ambil Actors Setelah Movies

```javascript
getData('./movies.json')
  .then((movies) => {
    console.log(movies);
    return getData('./actors.json'); // âœ… Return promise baru!
  })
  .then((actors) => {
    console.log(actors);
  });
```

### ğŸ”‘ **Konsep Penting:**

> ğŸ’¡ Apa yang kita `return` dari `.then()` akan diteruskan ke `.then()` berikutnya!

### Alur Eksekusi:

1. Ambil `movies.json` â†’ tunggu â†’ dapat data movies
2. Log movies ke console
3. **Return** `getData('./actors.json')` â†’ promise baru!
4. Promise tersebut di-handle oleh `.then()` berikutnya
5. Dapat data actors â†’ log ke console

---

### ğŸ“ Tambah Directors Juga!

```javascript
getData('./movies.json')
  .then((movies) => {
    console.log(movies);
    return getData('./actors.json');
  })
  .then((actors) => {
    console.log(actors);
    return getData('./directors.json'); // âœ… Return lagi!
  })
  .then((directors) => {
    console.log(directors);
  });
```

### ğŸ¨ Lihat Hasilnya!

Sekarang kode kita:

âœ… **Tidak berbentuk segitiga**  
âœ… **Mudah dibaca dari atas ke bawah**  
âœ… **Setiap `.then()` sejajar, tidak nested**  
âœ… **Lebih bersih dan maintainable!**

**Urutan Output:**

1. ğŸ¬ Movies (1-4 detik)
2. ğŸ­ Actors (1-4 detik setelah movies)
3. ğŸ¥ Directors (1-4 detik setelah actors)

---

<a name="error-handling-dengan-catch"></a>
## ğŸš¨ Error Handling dengan .catch()

Bagaimana jika ada error? Kita tambahkan `.catch()` untuk menangkap semua error!

```javascript
getData('./movies.json')
  .then((movies) => {
    console.log(movies);
    return getData('./actors.json');
  })
  .then((actors) => {
    console.log(actors);
    return getData('./directors.json');
  })
  .then((directors) => {
    console.log(directors);
  })
  .catch((error) => {
    console.log(error); // âœ… Tangkap semua error di sini!
  });
```

### ğŸ§ª Test Error Handling:

Coba ubah salah satu file name, misalnya:

```javascript
return getData('./directors1.json'); // âŒ File tidak ada!
```

Setelah save dan refresh browser:

1. âœ… Movies akan muncul
2. âœ… Actors akan muncul
3. âŒ Directors gagal â†’ `.catch()` akan jalan!
4. Output: `"Something went wrong"`

> ğŸ¯ **Keuntungan**: Satu `.catch()` di akhir bisa handle error dari semua `.then()` sebelumnya!

**Jangan lupa kembalikan ke nama file yang benar:**
```javascript
return getData('./directors.json');
```

---

<a name="kode-final"></a>
## ğŸ† Kode Final

### ğŸ“„ `index.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Promises vs Callback Hell</title>
  </head>
  <body>
    <h1>Promises vs Callback Hell</h1>

    <script src="./script.js"></script>
  </body>
</html>
```

### ğŸ“„ `script.js`

```javascript
function getData(endpoint) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();

    xhr.open('GET', endpoint);

    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(JSON.parse(this.responseText));
        } else {
          reject('Something went wrong');
        }
      }
    };

    setTimeout(() => {
      xhr.send();
    }, Math.floor(Math.random() * 3000) + 1000);
  });
}

// Promise Chaining - Whatever we return from a .then() 
// is passed into the next .then() callback function args
getData('./movies.json')
  .then((movies) => {
    console.log(movies);
    return getData('./actors.json');
  })
  .then((actors) => {
    console.log(actors);
    return getData('./directors.json');
  })
  .then((directors) => {
    console.log(directors);
  })
  .catch((error) => console.log(error));
```

---

<a name="kesimpulan"></a>
## ğŸ“ Kesimpulan

### ğŸ“Š Perbandingan: Callback vs Promise

| Aspek | Callback Hell âŒ | Promises âœ… |
|-------|-----------------|------------|
| **Readability** | Sulit dibaca (berbentuk segitiga) | Mudah dibaca (linear dari atas ke bawah) |
| **Maintainability** | Sulit di-maintain | Mudah di-maintain |
| **Error Handling** | Perlu di setiap callback | Satu `.catch()` untuk semua |
| **Code Structure** | Nested (bersarang) | Flat (sejajar) |
| **Debugging** | Sulit | Lebih mudah |

### âœ… Apa yang Sudah Kita Pelajari?

1. âœ¨ **Membuat Promise** dengan `new Promise(resolve, reject)`
2. ğŸ”— **Promise Chaining** dengan `.then()`
3. ğŸš¨ **Error Handling** dengan `.catch()`
4. ğŸ”„ **Refactoring** dari callback ke promises
5. ğŸ“ **Best Practices** dalam menulis asynchronous code

### ğŸš€ Next Steps

Video selanjutnya akan membahas:

- ğŸ¯ **Promise.all()** - Menjalankan beberapa promise secara paralel
- âš¡ Lebih cepat dan efisien!

### ğŸ’ª Latihan

Coba buat:

1. File JSON sendiri dengan data berbeda
2. Tambah lebih banyak `.then()` chaining
3. Sengaja buat error dan lihat bagaimana `.catch()` bekerja
4. Experiment dengan delay timeout yang berbeda

---

## ğŸ“Œ Catatan Penting

> ğŸ’¡ **Ingat**: Apapun yang kita `return` dari dalam `.then()` akan diteruskan ke `.then()` berikutnya sebagai parameter!

> âš ï¸ **Warning**: Jangan lupa `return` promise di dalam `.then()` kalau mau chain, kalau tidak promise berikutnya tidak akan jalan dengan benar!

> ğŸ¯ **Tips**: Promises membuat code lebih clean, tapi masih ada cara yang lebih modern lagi: **async/await**! (Itu topik untuk lain waktu)

---

**Happy Coding!** ğŸ‰ğŸ‘¨â€ğŸ’»ğŸ‘©â€ğŸ’»

*Dokumentasi ini dibuat untuk pembelajaran pribadi berdasarkan video tutorial.*
