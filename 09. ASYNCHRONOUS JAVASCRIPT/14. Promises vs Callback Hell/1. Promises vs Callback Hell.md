# ğŸ“š Dokumentasi: Refactoring Callback Hell ke Promises

> ğŸ“ **Dokumentasi Pribadi untuk Pemula**  
> Belajar cara mengubah nested callbacks (callback hell) menjadi Promise yang lebih clean dan mudah dibaca

---

## ğŸ“‹ Daftar Isi

- [Pengenalan](#pengenalan)
- [Apa itu Callback Hell?](#apa-itu-callback-hell)
- [Masalah dengan Callback Hell](#masalah-dengan-callback-hell)
- [Solusi: Menggunakan Promises](#solusi-menggunakan-promises)
- [Struktur File Project](#struktur-file-project)
- [Kode Sebelum Refactoring](#kode-sebelum-refactoring)
- [Proses Refactoring Step by Step](#proses-refactoring-step-by-step)
  - [Step 1: Membuat Promise](#step-1-membuat-promise)
  - [Step 2: Menggunakan Resolve dan Reject](#step-2-menggunakan-resolve-dan-reject)
  - [Step 3: Nested If untuk Status Check](#step-3-nested-if-untuk-status-check)
  - [Step 4: Menggunakan .then() untuk Chaining](#step-4-menggunakan-then-untuk-chaining)
  - [Step 5: Menambahkan Error Handling dengan .catch()](#step-5-menambahkan-error-handling-dengan-catch)
- [Kode Setelah Refactoring](#kode-setelah-refactoring)
- [Perbandingan Before vs After](#perbandingan-before-vs-after)
- [Cara Kerja Promise Chaining](#cara-kerja-promise-chaining)
- [Testing Error Handling](#testing-error-handling)
- [Kesimpulan](#kesimpulan)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

Dalam tutorial ini, kita akan belajar cara **mengubah kode dengan nested callbacks (callback hell)** menjadi **Promise-based code** yang lebih bersih dan mudah dibaca.

**Tujuan pembelajaran:**
- âœ… Memahami masalah callback hell
- âœ… Belajar menggunakan Promises
- âœ… Menggunakan Promise chaining dengan `.then()`
- âœ… Menambahkan error handling dengan `.catch()`

---

<a name="apa-itu-callback-hell"></a>
## ğŸ”¥ Apa itu Callback Hell?

**Callback Hell** adalah situasi dimana kita memiliki banyak **nested callbacks** (callback di dalam callback) yang membentuk pola seperti segitiga atau piramida.

**Contoh visual:**
```javascript
getData('./movies.json', (data) => {
  console.log(data);
  getData('./actors.json', (data) => {          // â† Nested 1 level
    console.log(data);
    getData('./directors.json', (data) => {      // â† Nested 2 levels
      console.log(data);
    });
  });
});
```

Perhatikan bentuk **segitiga** yang terbentuk! ğŸ“

---

<a name="masalah-dengan-callback-hell"></a>
## âŒ Masalah dengan Callback Hell

Callback hell menyebabkan beberapa masalah:

1. **ğŸ“– Sulit dibaca** - Kode terlihat berantakan
2. **ğŸ”§ Sulit di-maintain** - Susah untuk menambah atau mengubah logic
3. **ğŸ› Error handling kompleks** - Sulit menangani error di setiap level
4. **ğŸ˜µ Confusing** - Membingungkan untuk developer lain

---

<a name="solusi-menggunakan-promises"></a>
## âœ¨ Solusi: Menggunakan Promises

**Promise** adalah solusi modern untuk menangani operasi asynchronous. Dengan Promise, kita bisa:

- âœ… Menulis kode yang lebih **flat** (tidak bersarang)
- âœ… Menggunakan **chaining** dengan `.then()`
- âœ… Menangani error dengan **satu** `.catch()` saja
- âœ… Kode lebih **clean** dan **readable**

---

<a name="struktur-file-project"></a>
## ğŸ“ Struktur File Project

Sebelum mulai, pastikan kamu punya struktur file seperti ini:

```
ğŸ“¦ project-folder/
â”œâ”€â”€ ğŸ“„ index.html
â”œâ”€â”€ ğŸ“„ script.js
â”œâ”€â”€ ğŸ“„ movies.json
â”œâ”€â”€ ğŸ“„ actors.json
â””â”€â”€ ğŸ“„ directors.json
```

### ğŸ“„ File: `index.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Promises vs Callback Hell</title>
  </head>
  <body>
    <h1>Promises vs Callback Hell</h1>

    <script src="./script.js"></script>
  </body>
</html>
```

---

<a name="kode-sebelum-refactoring"></a>
## ğŸ”´ Kode Sebelum Refactoring

Ini adalah kode awal kita dengan **callback hell**:

```javascript
function getData(endpoint, cb) {
  const xhr = new XMLHttpRequest();

  xhr.open('GET', endpoint);

  xhr.onreadystatechange = function () {
    if ((this.readyState === 4) & (this.status === 200)) {
      cb(JSON.parse(this.responseText));
    }
  };

  setTimeout(() => {
    xhr.send();
  }, Math.floor(Math.random() * 3000) + 1000);
}

// ğŸ”¥ CALLBACK HELL - Nested callbacks!
getData('./movies.json', (data) => {
  console.log(data);
  getData('./actors.json', (data) => {
    console.log(data);
    getData('./directors.json', (data) => {
      console.log(data);
    });
  });
});
```

**Masalah di kode ini:**
- âŒ Tiga level nested callbacks
- âŒ Bentuk seperti segitiga
- âŒ Tidak ada error handling
- âŒ Sulit dibaca dan di-maintain

---

<a name="proses-refactoring-step-by-step"></a>
## ğŸ› ï¸ Proses Refactoring Step by Step

Mari kita ubah kode callback hell menjadi Promise step by step!

---

<a name="step-1-membuat-promise"></a>
### ğŸ“ Step 1: Membuat Promise

**Yang kita lakukan:**
1. **Hapus** parameter `cb` (callback)
2. **Return** sebuah `new Promise`

```javascript
function getData(endpoint) {  // â† Hapus parameter 'cb'
  return new Promise((resolve, reject) => {  // â† Return Promise baru
    const xhr = new XMLHttpRequest();
    xhr.open('GET', endpoint);
    
    // ... kode lainnya akan kita tambahkan
  });
}
```

**ğŸ’¡ Penjelasan:**
- `new Promise()` membuat Promise baru
- Promise menerima function dengan 2 parameter: `resolve` dan `reject`
- `resolve` = untuk success
- `reject` = untuk error

---

<a name="step-2-menggunakan-resolve-dan-reject"></a>
### ğŸ“ Step 2: Menggunakan Resolve dan Reject

**Yang kita lakukan:**
Pindahkan semua kode ke dalam Promise dan ganti callback dengan `resolve`:

```javascript
function getData(endpoint) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', endpoint);

    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(JSON.parse(this.responseText));  // â† Ganti cb() dengan resolve()
        } else {
          reject('Something went wrong');  // â† Untuk error
        }
      }
    };

    setTimeout(() => {
      xhr.send();
    }, Math.floor(Math.random() * 3000) + 1000);
  });
}
```

**ğŸ’¡ Penjelasan:**
- `resolve()` dipanggil ketika berhasil (status 200)
- `reject()` dipanggil ketika ada error (status bukan 200)

---

<a name="step-3-nested-if-untuk-status-check"></a>
### ğŸ“ Step 3: Nested If untuk Status Check

**âš ï¸ Kenapa perlu nested if?**

Sebelumnya, kode menggunakan AND operator:
```javascript
if ((this.readyState === 4) & (this.status === 200))
```

**Masalahnya:** Kita tidak bisa menambahkan `else` pada `readyState` karena nilai `readyState` akan melalui **2 dan 3** sebelum mencapai **4**.

**âœ… Solusi:** Gunakan nested if!

```javascript
xhr.onreadystatechange = function () {
  if (this.readyState === 4) {          // â† Cek readyState dulu
    if (this.status === 200) {          // â† Baru cek status
      resolve(JSON.parse(this.responseText));
    } else {
      reject('Something went wrong');   // â† Reject jika status bukan 200
    }
  }
};
```

**ğŸ’¡ Penjelasan:**
- Pertama cek `readyState === 4` (request selesai)
- Baru cek `status === 200` (success)
- Jika status bukan 200, kita `reject()` dengan pesan error

---

<a name="step-4-menggunakan-then-untuk-chaining"></a>
### ğŸ“ Step 4: Menggunakan .then() untuk Chaining

Sekarang kita gunakan fungsi `getData()` dengan **Promise chaining**:

```javascript
// âœ¨ PROMISE CHAINING - Flat dan clean!
getData('./movies.json')
  .then((movies) => {
    console.log(movies);
    return getData('./actors.json');  // â† Return Promise berikutnya
  })
  .then((actors) => {
    console.log(actors);
    return getData('./directors.json');  // â† Return Promise berikutnya
  })
  .then((directors) => {
    console.log(directors);
  });
```

**ğŸ’¡ Penjelasan:**
1. `getData('./movies.json')` memanggil function dan return Promise
2. `.then((movies) => {...})` dijalankan ketika Promise pertama berhasil
3. `return getData('./actors.json')` return Promise baru
4. Promise yang di-return akan masuk ke `.then()` berikutnya
5. Begitu seterusnya sampai selesai

**ğŸ¯ Keuntungan:**
- âœ… Tidak ada nested callbacks
- âœ… Kode berbentuk **flat** (lurus ke bawah)
- âœ… Mudah dibaca dan di-maintain

---

<a name="step-5-menambahkan-error-handling-dengan-catch"></a>
### ğŸ“ Step 5: Menambahkan Error Handling dengan .catch()

Tambahkan `.catch()` di akhir chain untuk menangani semua error:

```javascript
getData('./movies.json')
  .then((movies) => {
    console.log(movies);
    return getData('./actors.json');
  })
  .then((actors) => {
    console.log(actors);
    return getData('./directors.json');
  })
  .then((directors) => {
    console.log(directors);
  })
  .catch((error) => console.log(error));  // â† Tangkap semua error di sini!
```

**ğŸ’¡ Penjelasan:**
- `.catch()` akan menangkap error dari **semua** Promise di chain
- Jika salah satu Promise `reject()`, langsung loncat ke `.catch()`
- Kita cukup **satu** `.catch()` untuk semua error handling!

---

<a name="kode-setelah-refactoring"></a>
## ğŸŸ¢ Kode Setelah Refactoring

Ini adalah kode final setelah refactoring ke Promise:

```javascript
function getData(endpoint) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();

    xhr.open('GET', endpoint);

    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(JSON.parse(this.responseText));
        } else {
          reject('Something went wrong');
        }
      }
    };

    setTimeout(() => {
      xhr.send();
    }, Math.floor(Math.random() * 3000) + 1000);
  });
}

// âœ¨ Promise Chaining - Clean dan mudah dibaca!
getData('./movies.json')
  .then((movies) => {
    console.log(movies);
    return getData('./actors.json');
  })
  .then((actors) => {
    console.log(actors);
    return getData('./directors.json');
  })
  .then((directors) => {
    console.log(directors);
  })
  .catch((error) => console.log(error));
```

---

<a name="perbandingan-before-vs-after"></a>
## ğŸ“Š Perbandingan Before vs After

### ğŸ”´ Before (Callback Hell)

```javascript
getData('./movies.json', (data) => {
  console.log(data);
  getData('./actors.json', (data) => {
    console.log(data);
    getData('./directors.json', (data) => {
      console.log(data);
    });
  });
});
```

**Karakteristik:**
- âŒ Nested 3 level
- âŒ Bentuk segitiga
- âŒ Tidak ada error handling
- âŒ Sulit dibaca

### ğŸŸ¢ After (Promise Chaining)

```javascript
getData('./movies.json')
  .then((movies) => {
    console.log(movies);
    return getData('./actors.json');
  })
  .then((actors) => {
    console.log(actors);
    return getData('./directors.json');
  })
  .then((directors) => {
    console.log(directors);
  })
  .catch((error) => console.log(error));
```

**Karakteristik:**
- âœ… Flat, tidak nested
- âœ… Bentuk lurus ke bawah
- âœ… Ada error handling dengan `.catch()`
- âœ… Mudah dibaca dan di-maintain

---

<a name="cara-kerja-promise-chaining"></a>
## ğŸ”— Cara Kerja Promise Chaining

**Konsep penting:**  
> **Apapun yang kita `return` dari `.then()` akan diteruskan ke `.then()` berikutnya!**

```javascript
getData('./movies.json')           // â† Return Promise 1
  .then((movies) => {               // â† Terima hasil Promise 1
    console.log(movies);
    return getData('./actors.json'); // â† Return Promise 2
  })
  .then((actors) => {               // â† Terima hasil Promise 2
    console.log(actors);
    return getData('./directors.json'); // â† Return Promise 3
  })
  .then((directors) => {            // â† Terima hasil Promise 3
    console.log(directors);
  });
```

**ğŸ“ Urutan eksekusi:**
1. **Movies** akan selalu ditampilkan **pertama**
2. **Actors** akan ditampilkan **kedua** (setelah movies selesai)
3. **Directors** akan ditampilkan **ketiga** (setelah actors selesai)

**â±ï¸ Timing:**
- Setiap request punya delay random 1-4 detik
- Tapi urutan selalu **berurutan** karena chaining

---

<a name="testing-error-handling"></a>
## ğŸ§ª Testing Error Handling

Untuk test apakah error handling bekerja, **ubah salah satu endpoint** menjadi salah:

```javascript
getData('./movies.json')
  .then((movies) => {
    console.log(movies);
    return getData('./actors.json');
  })
  .then((actors) => {
    console.log(actors);
    return getData('./directors1.json');  // â† Salah! (tambah angka 1)
  })
  .then((directors) => {
    console.log(directors);
  })
  .catch((error) => console.log(error));  // â† Akan tangkap error!
```

**Yang terjadi:**
1. âœ… Movies akan ditampilkan (berhasil)
2. âœ… Actors akan ditampilkan (berhasil)
3. âŒ Directors akan error (file tidak ada)
4. ğŸ¯ `.catch()` akan menangkap error dan menampilkan: `"Something went wrong"`

**ğŸ’¡ Catatan:**
- Kamu bisa custom error message sesuai kebutuhan
- Kamu juga bisa menampilkan popup error jika diperlukan
- Error handling jadi lebih mudah dengan satu `.catch()` saja!

---

<a name="kesimpulan"></a>
## ğŸ“ Kesimpulan

### âœ… Apa yang sudah kita pelajari:

1. **Callback Hell** adalah nested callbacks yang sulit dibaca
2. **Promise** adalah solusi modern untuk async operations
3. **Promise chaining** membuat kode lebih clean dengan `.then()`
4. **Error handling** jadi mudah dengan satu `.catch()` saja
5. **Nested if** diperlukan untuk cek `readyState` dan `status` dengan benar

### ğŸš€ Next Steps:

Video berikutnya akan membahas **`Promise.all()`** yang bisa membuat kode ini **lebih clean lagi**!

`Promise.all()` berguna untuk:
- Menjalankan multiple Promises **secara parallel**
- Menunggu semua Promises selesai sekaligus
- Lebih efisien daripada chaining

---

### ğŸ’ª Practice Tips:

1. âœï¸ **Tulis ulang kode ini dari awal** tanpa melihat
2. ğŸ”„ **Coba buat request ke API lain** (misalnya JSONPlaceholder)
3. ğŸ¨ **Tampilkan data ke HTML** instead of console.log
4. ğŸ› **Experiment dengan error handling** yang berbeda

---

**ğŸ‰ Selamat! Kamu sudah berhasil refactor dari Callback Hell ke Promises!**

---

ğŸ“ **Dokumentasi Pribadi** | ğŸ“ **Belajar Step by Step** | ğŸ’» **Practice Makes Perfect**
