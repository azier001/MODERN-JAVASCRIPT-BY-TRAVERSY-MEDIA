# ğŸ“š Dokumentasi Asynchronous JavaScript untuk Pemula

> ğŸ“ **Catatan Belajar Pribadi** - Dokumentasi ini dibuat untuk memahami konsep asynchronous JavaScript step by step.

---

## ğŸ“‘ Daftar Isi

- [Pengenalan](#pengenalan)
- [Synchronous vs Asynchronous](#synchronous-vs-asynchronous)
- [Thread of Execution](#thread-of-execution)
- [Blocking vs Non-Blocking Code](#blocking-vs-non-blocking-code)
  - [Contoh Blocking Code](#contoh-blocking-code)
  - [Contoh Non-Blocking Code](#contoh-non-blocking-code)
- [JavaScript Engine & Web APIs](#javascript-engine-web-apis)
  - [Core JavaScript](#core-javascript)
  - [Web APIs](#web-apis)
- [Event Loop & Task Queue](#event-loop-task-queue)
  - [Cara Kerja Task Queue](#cara-kerja-task-queue)
  - [Event Loop](#event-loop)
- [Promises & Microtask Queue](#promises-microtask-queue)
- [Kesimpulan](#kesimpulan)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

Selamat datang di dokumentasi tentang **Asynchronous JavaScript**! ğŸš€

Di sini kita akan mempelajari **apa yang terjadi di balik layar** (under the hood) ketika kita menjalankan kode asynchronous di JavaScript. 

âš ï¸ **Peringatan**: Materi ini cukup padat, tapi jangan khawatir! Kita akan belajar sedikit demi sedikit. Jika ada yang membingungkan, itu wajar. Pemahaman akan semakin baik seiring berjalannya waktu.

---

<a name="synchronous-vs-asynchronous"></a>
## ğŸ”„ Synchronous vs Asynchronous

### ğŸ“Œ **JavaScript itu Synchronous!**

> **JavaScript secara default adalah synchronous dan single-threaded.**

Apa artinya?

- **Synchronous** = Kode dijalankan **baris per baris**, dari atas ke bawah
- **Single-threaded** = Hanya ada **satu jalur eksekusi** (thread of execution)

ğŸ’¡ **Analogi Sederhana**: 
Bayangkan kamu antri di kasir. Kamu harus menunggu orang di depan selesai dulu baru giliran kamu. Itulah synchronous!

---

<a name="thread-of-execution"></a>
## ğŸ§µ Thread of Execution

**Thread of Execution** adalah jalur di mana JavaScript menjalankan kode kita.

### ğŸ“Š **Visualisasi:**

```
THREAD OF EXECUTION
        â†“
   OPERATION 1  â†’ console.log(1);
        â†“
   OPERATION 2  â†’ console.log(2);
        â†“
   OPERATION 3  â†’ console.log(3);
        â†“
   OPERATION 4  â†’ console.log(4);
        â†“
  CALL STACK | MEMORY HEAP
```

âœ… Setiap operasi **menunggu** operasi sebelumnya selesai.

---

<a name="blocking-vs-non-blocking-code"></a>
## ğŸš¦ Blocking vs Non-Blocking Code

### âŒ **Blocking Code**

**Blocking code** adalah kode yang **menghentikan** atau **memblokir** eksekusi sampai operasi selesai.

**Contoh situasi blocking:**
- ğŸ“¡ Fetching data dari server
- ğŸ“„ Membaca/menulis file (di Node.js)
- â±ï¸ Operasi yang memakan waktu beberapa detik/milidetik

âš ï¸ **Masalah**: Semua kode lain harus **menunggu** sampai operasi ini selesai!

<a name="contoh-blocking-code"></a>
### ğŸ“ **Contoh: Blocking Code (Node.js)**

```javascript
const fs = require('fs');
const filepath = 'text.txt';

// Reads a file in a synchronous and blocking way
const data = fs.readFileSync(filepath, {encoding: 'utf8'});

// Prints the content of file
console.log(data);

// This section calculates the sum of numbers from 1 to 10
let sum = 0;
for(let i=1; i<=10; i++){
    sum = sum + i;
}

// Prints the sum
console.log('Sum: ', sum);
```

**Output:**
```
This is from text file.
Sum: 55
```

ğŸ” **Penjelasan Alur:**
1. â¸ï¸ Kode **BERHENTI** di `readFileSync` â†’ menunggu file dibaca
2. âœ… Setelah file dibaca â†’ simpan di variabel `data`
3. ğŸ“¤ Console log data dari file
4. ğŸ”¢ Jalankan perhitungan sum
5. ğŸ“¤ Console log sum

---

<a name="contoh-non-blocking-code"></a>
### âœ… **Non-Blocking Code**

**Non-blocking code** adalah kode yang **TIDAK** menghentikan eksekusi. Kode lain tetap berjalan!

### ğŸ“ **Contoh: Non-Blocking Code (Node.js)**

```javascript
const fs = require('fs');
const filepath = 'text.txt';

// Reads a file in an asynchronous and non-blocking way
fs.readFile(filepath, {encoding: 'utf8'}, (err, data) => {
    // Prints the content of file
    console.log(data);
});

// This section calculates the sum of numbers from 1 to 10
let sum = 0;
for(let i=1; i<=10; i++){
    sum = sum + i;
}

// Prints the sum
console.log('Sum: ', sum);
```

**Output:**
```
Sum: 55
This is from text file.
```

ğŸ” **Penjelasan Alur:**
1. ğŸš€ Panggil `readFile` dengan **callback function**
2. â­ï¸ **TIDAK MENUNGGU!** Langsung lanjut ke kode berikutnya
3. ğŸ”¢ Jalankan perhitungan sum
4. ğŸ“¤ Console log sum (muncul **DULUAN**)
5. âœ… Setelah file selesai dibaca â†’ jalankan callback
6. ğŸ“¤ Console log data dari file (muncul **BELAKANGAN**)

---

## ğŸ¨ **Perbandingan Visual**

| **BLOCKING CODE** | **NON-BLOCKING CODE** |
|-------------------|------------------------|
| â¸ï¸ Tunggu operasi selesai | â­ï¸ Lanjut ke kode berikutnya |
| ğŸŒ Lambat jika ada operasi berat | âš¡ Tetap responsif |
| Output: Data â†’ Sum | Output: Sum â†’ Data |

---

<a name="javascript-engine-web-apis"></a>
## âš™ï¸ JavaScript Engine & Web APIs

### ğŸ¯ **Konsep Penting!**

JavaScript **SENDIRI** itu synchronous, tapi kita bisa menulis kode **asynchronous** menggunakan **Web APIs**!

<a name="core-javascript"></a>
### ğŸ“¦ **Core JavaScript (JS Engine)**

**Kotak Kuning di Diagram** = JavaScript Engine inti

Isinya:
- ğŸ“š **Call Stack** - Tempat function dieksekusi
- ğŸ§  **Memory Heap** - Tempat variabel & objek disimpan
- ğŸŒ **Global Execution Context** - Environment global

âœ… Bagian ini **SYNCHRONOUS** - berjalan line by line!

<a name="web-apis"></a>
### ğŸŒ **Web APIs**

**Kotak Hijau di Diagram** = Web APIs yang disediakan browser/Node.js

Berisi fungsi-fungsi asynchronous seperti:
- â° `setTimeout()` - Timer
- ğŸ” `setInterval()` - Interval
- ğŸŒ `fetch()` - HTTP Request
- ğŸ“¡ `AJAX (XMLHttpRequest)` - HTTP Request
- ğŸ¨ `DOM API` - Manipulasi HTML

ğŸ” **Cara Membuktikan:**
Buka browser console dan ketik:
```javascript
window
```

Scroll dan cari:
- `setTimeout` âœ…
- `setInterval` âœ…
- `fetch` âœ…

**Kesimpulan**: Fungsi-fungsi ini **BUKAN** bagian dari JavaScript inti! Mereka disediakan oleh **environment** (browser/Node.js).

---

<a name="event-loop-task-queue"></a>
## ğŸ”„ Event Loop & Task Queue

### ğŸ¯ **Komponen Penting**

Ada 3 komponen utama dalam sistem asynchronous JavaScript:

1. ğŸ“‹ **Task Queue (Callback Queue)**
2. ğŸ” **Event Loop**
3. ğŸ“š **Call Stack**

<a name="cara-kerja-task-queue"></a>
### ğŸ“‹ **Task Queue**

> **Task Queue adalah antrian untuk callback functions**

**Karakteristik:**
- ğŸ“Š Struktur data: **Queue** (FIFO - First In First Out)
- ğŸ¥‡ Yang pertama masuk â†’ yang pertama keluar
- ğŸ“ Tempat penyimpanan callback yang sudah siap dieksekusi

ğŸ’¡ **Analogi**: Antrian di bank. Yang datang duluan, dilayani duluan!

**Queue vs Stack:**
- **Stack** (Call Stack): Last In First Out â¬†ï¸
- **Queue** (Task Queue): First In First Out â¡ï¸

<a name="event-loop"></a>
### ğŸ” **Event Loop**

> **Event Loop adalah "penjaga pintu" yang mengatur kapan callback masuk ke Call Stack**

**Tugas Event Loop:**
1. ğŸ‘€ Monitor Call Stack - apakah kosong?
2. ğŸ‘€ Monitor Task Queue - apakah ada callback?
3. âœ… Jika Call Stack **KOSONG** â†’ ambil callback dari Task Queue
4. ğŸ“š Masukkan callback ke Call Stack untuk dieksekusi
5. ğŸ” Ulangi terus (loop!)

ğŸ’¡ **Analogi Pintu Putar**:
Event Loop seperti pintu putar di mall yang terus berputar. Ketika ada orang (callback), pintu membiarkan mereka masuk satu per satu.

---

### ğŸ¬ **Alur Lengkap: setTimeout Example**

```javascript
console.log('Start');

setTimeout(() => {
  console.log('Callback');
}, 2000);

console.log('End');
```

**Yang Terjadi:**

1. ğŸ“¤ `console.log('Start')` â†’ Execute di Call Stack â†’ Output: "Start"
2. â° `setTimeout()` dipanggil:
   - ğŸŒ Dikirim ke **Web APIs**
   - â±ï¸ Timer mulai berjalan (2000ms)
   - â­ï¸ Call Stack **KOSONG**, lanjut ke baris berikutnya
3. ğŸ“¤ `console.log('End')` â†’ Execute di Call Stack â†’ Output: "End"
4. â° Setelah 2 detik:
   - âœ… Timer selesai di Web APIs
   - ğŸ“‹ Callback masuk ke **Task Queue**
5. ğŸ” **Event Loop** cek:
   - â“ Call Stack kosong? âœ… YA
   - â“ Ada callback di Task Queue? âœ… ADA
   - ğŸ“š Pindahkan callback ke Call Stack
6. ğŸ“¤ `console.log('Callback')` â†’ Execute â†’ Output: "Callback"

**Final Output:**
```
Start
End
Callback
```

---

<a name="promises-microtask-queue"></a>
## ğŸ Promises & Microtask Queue

### ğŸ†š **Promises vs Callbacks**

Ada 2 cara menangani asynchronous:
1. â˜ï¸ **Callbacks** (seperti setTimeout)
2. ğŸ **Promises** (seperti fetch)

### â­ **Microtask Queue (Promise Jobs)**

> **Promises punya antrian KHUSUS yang lebih prioritas!**

**Perbedaan dengan Task Queue:**

| **Task Queue** | **Microtask Queue** |
|----------------|---------------------|
| Untuk callbacks biasa | Untuk Promises |
| â¸ï¸ Prioritas normal | âš¡ Prioritas **LEBIH TINGGI** |
| setTimeout, setInterval | fetch, Promise.then |

### ğŸ¬ **Alur: fetch() Example**

```javascript
console.log('Start');

fetch('https://api.example.com/data')
  .then(data => console.log('Data received'));

console.log('End');
```

**Yang Terjadi:**

1. ğŸ“¤ Output: "Start"
2. ğŸŒ `fetch()` dipanggil â†’ dikirim ke Web APIs
3. ğŸ“¤ Output: "End"
4. âœ… Fetch selesai â†’ `.then()` callback masuk ke **Microtask Queue**
5. ğŸ” Event Loop cek:
   - â“ Call Stack kosong? âœ… YA
   - â“ Ada di **Microtask Queue**? âœ… PRIORITAS!
   - ğŸ“š Execute callback dari Microtask Queue **DULUAN**
6. ğŸ“¤ Output: "Data received"

**Final Output:**
```
Start
End
Data received
```

---

### ğŸ† **Priority System**

```
PRIORITAS EKSEKUSI:
1. ğŸ“š Call Stack (synchronous code)
2. âš¡ Microtask Queue (Promises) - HIGH PRIORITY
3. ğŸ“‹ Task Queue (Callbacks) - Normal Priority
```

ğŸ’¡ **Ingat**: Microtask Queue **SELALU** dieksekusi sebelum Task Queue!

---

<a name="kesimpulan"></a>
## ğŸ“ Kesimpulan

### âœ… **Poin-Poin Penting**

1. **JavaScript = Synchronous & Single-Threaded**
   - Kode berjalan baris per baris
   - Hanya ada 1 thread eksekusi

2. **Blocking vs Non-Blocking**
   - âŒ Blocking = menghentikan eksekusi
   - âœ… Non-Blocking = tetap berjalan

3. **JavaScript Engine vs Web APIs**
   - ğŸ“¦ JS Engine = Core (synchronous)
   - ğŸŒ Web APIs = Asynchronous capabilities

4. **Event Loop System**
   - ğŸ“‹ Task Queue = Antrian callbacks
   - ğŸ” Event Loop = Pengatur traffic
   - ğŸ“š Call Stack = Tempat eksekusi

5. **Promises itu Spesial!**
   - âš¡ Punya Microtask Queue sendiri
   - ğŸ† Prioritas lebih tinggi dari callbacks

---

### ğŸ“š **Apa Selanjutnya?**

Setelah memahami konsep dasar ini, kita akan belajar:

- â˜ï¸ **Callbacks** & Callback Hell
- ğŸ **Promises** - Cara membuat dan menggunakan
- ğŸŒ **Fetch API** - HTTP Requests
- â±ï¸ **XMLHttpRequest (XHR)** - Legacy HTTP
- âœ¨ **Async/Await** - Cara modern handle Promises

---

### ğŸ¯ **Tips Belajar**

1. ğŸ¢ **Jangan terburu-buru** - Konsep ini butuh waktu untuk dipahami
2. ğŸ’» **Praktik langsung** - Tulis kode dan lihat hasilnya
3. ğŸ” **Eksperimen** - Ubah-ubah kode untuk lihat perbedaan
4. ğŸ“ **Review berkala** - Baca ulang dokumentasi ini
5. ğŸ’ª **Tetap semangat** - Semua programmer pernah bingung di tahap ini!

---

> ğŸ‰ **Selamat!** Kamu sudah memahami fondasi Asynchronous JavaScript!  
> ğŸ’ª Terus belajar dan praktik! Happy Coding! ğŸš€

---

**ğŸ“… Dokumentasi Pribadi** | **ğŸ“ Untuk Pembelajaran JavaScript**
