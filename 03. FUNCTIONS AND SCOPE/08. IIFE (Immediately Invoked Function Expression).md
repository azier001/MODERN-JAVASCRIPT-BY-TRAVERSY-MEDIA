# ğŸ“š Dokumentasi IIFE (Immediately Invoked Function Expression)

> **Catatan Pribadi:** Dokumentasi ini dibuat untuk mempelajari konsep IIFE dalam JavaScript secara bertahap dan mudah dipahami.

---

## ğŸ“‹ Daftar Isi

- [Pengenalan](#pengenalan)
- [Apa itu IIFE?](#apa-itu-iife)
- [Mengapa Menggunakan IIFE?](#mengapa-menggunakan-iife)
- [Masalah Global Scope Pollution](#masalah-global-scope-pollution)
- [Syntax Dasar IIFE](#syntax-dasar-iife)
- [IIFE dengan Parameter](#iife-dengan-parameter)
- [Named IIFE](#named-iife)
- [Kesimpulan](#kesimpulan)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

Biasanya ketika kita bekerja dengan fungsi di JavaScript, kita:
1. âœï¸ **Mendeklarasikan** fungsi terlebih dahulu
2. â–¶ï¸ **Memanggil/menjalankan** fungsi tersebut ketika dibutuhkan

Namun, ada cara khusus di JavaScript yang memungkinkan kita untuk **membuat dan menjalankan fungsi secara bersamaan**. Cara ini disebut **IIFE**.

---

<a name="apa-itu-iife"></a>
## ğŸ“– Apa itu IIFE?

**IIFE** adalah singkatan dari **Immediately Invoked Function Expression**, yang artinya:
- ğŸš€ **Immediately Invoked** = Langsung dijalankan
- ğŸ”§ **Function Expression** = Ekspresi fungsi

> ğŸ’¡ **Cara Baca:** IIFE dibaca "iffy" (seperti kata "iffy" dalam bahasa Inggris)

IIFE adalah fungsi yang **dibuat dan langsung dijalankan** tanpa perlu dipanggil secara terpisah.

---

<a name="mengapa-menggunakan-iife"></a>
## ğŸ¤” Mengapa Menggunakan IIFE?

Alasan utama menggunakan IIFE adalah untuk **menghindari Global Scope Pollution** (pencemaran scope global).

### â“ Apa itu Global Scope Pollution?

Global Scope Pollution terjadi ketika terlalu banyak variabel atau fungsi dideklarasikan di scope global, yang dapat menyebabkan:
- âš ï¸ **Konflik nama variabel** antar file
- ğŸ› **Error** yang sulit dilacak
- ğŸ”’ **Kurang aman** karena semua variabel bisa diakses dari mana saja

---

<a name="masalah-global-scope-pollution"></a>
## âš¡ Masalah Global Scope Pollution

### Contoh Kasus Masalah:

**File: other-script.js** (Library dari developer lain)
```javascript
// Variabel global
const user = 'Brad';
console.log(user); // Output: Brad
```

**File: script.js** (File kita)
```javascript
// Kita juga ingin menggunakan variabel bernama 'user'
const user = 'John'; // âŒ ERROR: user has already been declared
```

**Masalah:** Kedua file menggunakan variabel dengan nama yang sama di scope global, sehingga terjadi konflik! ğŸ’¥

### âœ… Solusi dengan IIFE:

**File: script.js**
```javascript
// Menggunakan IIFE untuk menghindari konflik
(function () {
  const user = 'John'; // âœ… Aman! Variabel ini ada di scope IIFE
  console.log(user); // Output: John
})();

// Variabel 'user' dari other-script.js tetap bisa digunakan
```

**Penjelasan:**
- ğŸ” Variabel `user` di dalam IIFE memiliki **scope tersendiri**
- ğŸš« Tidak akan bentrok dengan variabel `user` di file lain
- âœ… Kedua variabel bisa hidup berdampingan tanpa masalah

---

<a name="syntax-dasar-iife"></a>
## ğŸ“ Syntax Dasar IIFE

### Format Penulisan IIFE:

```javascript
(function () {
  // Kode di sini
})();
```

**Penjelasan Struktur:**
1. **`( )`** pertama = Membungkus deklarasi fungsi
2. **`function () { }`** = Fungsi anonymous (tanpa nama)
3. **`( )`** kedua = Memanggil/menjalankan fungsi tersebut

> ğŸ¯ **Kunci Penting:** Dua pasang tanda kurung `()()` adalah ciri khas IIFE!

### Contoh Praktik:

```javascript
// IIFE dengan variabel dan fungsi di dalamnya
(function () {
  const user = 'John';
  console.log(user); // Output: John
  
  const hello = () => console.log('Hello from the IIFE');
  hello(); // Output: Hello from the IIFE
})();
```

**Yang Terjadi:**
1. âœ… Fungsi dibuat
2. âœ… Fungsi langsung dijalankan
3. âœ… Variabel `user` dan fungsi `hello` hanya ada di dalam scope IIFE
4. âœ… Setelah selesai, fungsi tidak bisa dipanggil lagi dari luar

### âš ï¸ Tidak Bisa Diakses dari Luar:

```javascript
(function () {
  const hello = () => console.log('Hello from the IIFE');
  hello(); // âœ… Berhasil (dipanggil dari dalam IIFE)
})();

hello(); // âŒ ERROR: hello is not defined (tidak bisa diakses dari luar)
```

---

<a name="iife-dengan-parameter"></a>
## ğŸ IIFE dengan Parameter

IIFE juga bisa menerima parameter seperti fungsi biasa!

### Syntax dengan Parameter:

```javascript
(function (parameter) {
  // Gunakan parameter di sini
})(nilai_yang_dikirim);
```

### Contoh Praktik:

```javascript
// IIFE dengan satu parameter
(function (name) {
  console.log('Hello ' + name);
})('Shawn');
// Output: Hello Shawn
```

**Penjelasan:**
- ğŸ“¥ **`(name)`** = Parameter yang diterima fungsi
- ğŸ“¤ **`('Shawn')`** = Nilai yang dikirim ke parameter `name`
- ğŸ”„ Nilai `'Shawn'` masuk ke parameter `name`, lalu digunakan dalam fungsi

### Contoh dengan Multiple Parameter:

```javascript
// IIFE dengan beberapa parameter
(function (firstName, lastName, age) {
  console.log(`Nama: ${firstName} ${lastName}, Umur: ${age}`);
})('John', 'Doe', 25);
// Output: Nama: John Doe, Umur: 25
```

---

<a name="named-iife"></a>
## ğŸ·ï¸ Named IIFE (IIFE dengan Nama)

Kita juga bisa memberi nama pada IIFE, meskipun **jarang digunakan**.

### Syntax Named IIFE:

```javascript
(function namaFungsi() {
  // Kode di sini
})();
```

### Contoh Praktik:

```javascript
// IIFE dengan nama 'hello'
(function hello() {
  console.log('Hello');
})();
// Output: Hello
```

### âš ï¸ Batasan Named IIFE:

```javascript
(function hello() {
  console.log('Hello');
})();

hello(); // âŒ ERROR: hello is not defined
```

**Penjelasan:**
- ğŸš« Nama fungsi `hello` **hanya bisa diakses dari dalam fungsi itu sendiri**
- ğŸ”’ Tidak bisa dipanggil dari luar scope IIFE
- ğŸ“Œ Ini sama seperti IIFE anonymous biasa

### ğŸ” Kapan Named IIFE Berguna?

Named IIFE berguna untuk:
1. **Recursion** (fungsi memanggil dirinya sendiri)
2. **Debugging** (nama fungsi muncul di error stack trace)

**Contoh Recursion (HATI-HATI!):**

```javascript
(function countdown(num) {
  if (num > 0) {
    console.log(num);
    countdown(num - 1); // Memanggil dirinya sendiri
  }
})(5);
// Output: 5, 4, 3, 2, 1
```

**âš ï¸ PERINGATAN:** Jangan membuat recursion tanpa kondisi berhenti, atau browser akan crash!

```javascript
// âŒ JANGAN LAKUKAN INI!
(function hello() {
  console.log('Hello');
  hello(); // Akan terus memanggil dirinya sendiri tanpa henti = INFINITE LOOP
})();
```

---

<a name="kesimpulan"></a>
## ğŸ“ Kesimpulan

### Ringkasan IIFE:

| Aspek | Penjelasan |
|-------|------------|
| ğŸ“Œ **Definisi** | Fungsi yang langsung dijalankan setelah dibuat |
| ğŸ¯ **Tujuan Utama** | Menghindari Global Scope Pollution |
| ğŸ“ **Syntax** | `(function(){ ... })()` |
| ğŸ **Parameter** | Bisa menerima parameter seperti fungsi biasa |
| ğŸ·ï¸ **Named IIFE** | Jarang digunakan, kecuali untuk recursion/debugging |
| ğŸ”’ **Scope** | Variabel & fungsi di dalam IIFE bersifat private |

### âœ… Keuntungan IIFE:

- ğŸ›¡ï¸ **Proteksi Scope:** Variabel tidak mencemari global scope
- ğŸ” **Privacy:** Data di dalam IIFE tidak bisa diakses dari luar
- ğŸš€ **Langsung Eksekusi:** Tidak perlu memanggil fungsi secara terpisah
- ğŸ“¦ **Modular:** Kode lebih terorganisir dan tidak bentrok dengan library lain

### ğŸ’¡ Kapan Menggunakan IIFE?

- ğŸ”§ Saat menggunakan **multiple libraries** yang mungkin konflik
- ğŸŒ Saat ingin **menghindari variabel global**
- ğŸ”’ Saat butuh **privacy/encapsulation** untuk data tertentu
- ğŸš€ Saat kode hanya perlu **dijalankan sekali** saat load

### ğŸ“Œ Catatan Penting:

> Di JavaScript modern (ES6+), kita bisa menggunakan **modules** dan **block scope** (`let`/`const`) sebagai alternatif IIFE. Namun, IIFE masih berguna dan sering ditemui di codebase lama atau library JavaScript.

---

## ğŸ‰ Selamat Belajar!

Terus berlatih dan eksperimen dengan IIFE untuk memahami konsepnya lebih dalam! ğŸ’ª

---
