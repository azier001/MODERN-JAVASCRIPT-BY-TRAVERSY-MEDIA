# ğŸ”— JavaScript â€” Memahami `bind()`

> ğŸ““ *Catatan pribadi dari video tutorial â€” untuk pemula yang baru belajar JavaScript*

---

## ğŸ“‹ Daftar Isi

- [Pengenalan `this`](#pengenalan-this)
- [Masalah `this` dalam Callback](#masalah-this-dalam-callback)
- [Solusi: Menggunakan `bind()`](#solusi-menggunakan-bind)
- [Contoh Lengkap](#contoh-lengkap)
- [Ringkasan](#ringkasan)

---

<a name="pengenalan-this"></a>
## ğŸ¯ Pengenalan `this`

Keyword `this` di JavaScript bersifat **dinamis** â€” artinya nilainya bisa berubah tergantung *di mana* dan *kapan* kamu menggunakannya. Berikut gambaran singkatnya:

| Konteks | `this` merujuk ke... |
|---|---|
| Global scope / regular function | `window` object |
| Constructor function / class | Instance dari object tersebut |
| Event listener | Element yang memicu event |

Karena banyaknya situasi yang berbeda, JavaScript menyediakan tiga method untuk **mengatur `this` secara manual**, yaitu: `call`, `apply`, dan `bind`.

---

<a name="masalah-this-dalam-callback"></a>
## ğŸ› Masalah `this` dalam Callback

Bayangkan kamu punya sebuah `class` bernama `App` dengan property `serverName` dan sebuah method `getServerName`:

```javascript
class App {
  constructor() {
    this.serverName = 'localhost';
  }

  getServerName() {
    console.log(this.serverName);
  }
}

const app = new App();
app.getServerName(); // âœ… Output: "localhost"
```

Ini bekerja dengan baik. Tapi bagaimana kalau kita panggil `getServerName` melalui sebuah **event listener**?

```javascript
class App {
  constructor() {
    this.serverName = 'localhost';

    // âŒ Masalah ada di sini!
    document.querySelector('button')
      .addEventListener('click', this.getServerName);
  }

  getServerName() {
    console.log(this.serverName);
  }
}
```

Saat tombol diklik, hasilnya adalah... **`undefined`**! ğŸ˜±

**Kenapa?** Karena callback function dipanggil sebagai *regular function* biasa. Di dalam event listener, `this` secara default merujuk ke **element HTML** yang memicu event â€” yaitu tombol `<button>`, bukan object `App`. Dan tombol tidak punya property `serverName`, jadi hasilnya `undefined`.

> ğŸ’¡ Kalau kamu `console.log(this)` di dalam event handler tanpa `bind`, yang muncul adalah element `<button>` itu sendiri â€” bukan object `App`.

---

<a name="solusi-menggunakan-bind"></a>
## âœ… Solusi: Menggunakan `bind()`

`bind()` memungkinkan kita untuk **menentukan secara manual** apa yang dimaksud `this` di dalam sebuah function. Method ini mengembalikan **function baru** di mana nilai `this` sudah terikat ke apapun yang kita masukkan sebagai argumen.

Cara pakainya sangat mudah â€” cukup tambahkan `.bind(this)` setelah nama method:

```javascript
// Sebelum: âŒ
this.getServerName

// Sesudah: âœ…
this.getServerName.bind(this)
```

Dengan `.bind(this)`, kita bilang: *"Hei, saat `getServerName` dipanggil nanti, pastikan `this` di dalamnya tetap merujuk ke object `App` ini."*

---

<a name="contoh-lengkap"></a>
## ğŸ’» Contoh Lengkap

Berikut kode lengkap yang sudah diperbaiki menggunakan `bind()`:

```javascript
class App {
  constructor() {
    this.serverName = 'localhost';

    // âœ… Gunakan .bind(this) agar `this` tetap merujuk ke instance App
    document
      .querySelector('button')
      .addEventListener('click', this.getServerName.bind(this));
  }

  getServerName() {
    console.log(this); // Sekarang ini adalah object App, bukan button!
  }
}

const app = new App();
```

Sekarang saat tombol diklik, `this` di dalam `getServerName` akan merujuk ke **instance `App`**, dan `this.serverName` akan menampilkan `"localhost"` dengan benar. ğŸ‰

> ğŸ“Œ **Tips:** Constructor adalah tempat yang bagus untuk menaruh event listener karena constructor otomatis berjalan saat object diinstansiasi dengan `new App()`.

---

<a name="ringkasan"></a>
## ğŸ“ Ringkasan

- `this` di JavaScript bersifat **dinamis** â€” nilainya tergantung konteks
- Saat method kelas dipakai sebagai **callback** (misalnya di event listener), `this` berubah menjadi element HTML pemicu event
- Gunakan **`.bind(this)`** untuk "mengunci" nilai `this` agar tetap merujuk ke instance yang kamu inginkan
- `bind()` mengembalikan **function baru** â€” jadi kamu tidak perlu memanggilnya langsung
- Kamu **hanya perlu** `bind` kalau method tersebut menggunakan keyword `this` di dalamnya

```javascript
// Pola yang perlu diingat:
.addEventListener('click', this.namaMethod.bind(this));
//                                         ^^^^^^^^^^^
//                                  ini yang "mengunci" this
```
