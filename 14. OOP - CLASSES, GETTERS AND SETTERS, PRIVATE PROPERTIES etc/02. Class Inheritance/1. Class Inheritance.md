# ğŸ—ï¸ JavaScript Class Inheritance

> Dokumentasi pribadi â€” belajar dari video tutorial JavaScript OOP

---

## ğŸ“‹ Daftar Isi

- [Pengenalan](#pengenalan)
- [Parent Class â€” Shape](#parent-class)
- [Subclass dengan `extends`](#subclass-extends)
- [Keyword `super`](#keyword-super)
- [Method di Parent Class](#method-parent)
- [Polymorphism â€” Override Method](#polymorphism)
- [instanceof](#instanceof)
- [Kode Lengkap](#kode-lengkap)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

Class inheritance di JavaScript itu **jauh lebih mudah** dibanding cara lama pakai constructor dan prototype manual. Kenapa? Karena banyak hal sudah dikerjakan otomatis *di balik layar* oleh JavaScript.

Meskipun begitu, tetap bagus kalau kita tahu cara kerja prototype di bawahnya â€” tapi untuk sehari-hari, pakai `class` sudah cukup nyaman.

> ğŸ’¡ **Intinya:** Inheritance = satu class "mewarisi" sifat-sifat dari class lain, supaya kita tidak perlu nulis ulang kode yang sama berkali-kali.

---

<a name="parent-class"></a>
## ğŸ‘‘ Parent Class â€” Shape

Kita mulai dengan membuat **parent class** (class induk) bernama `Shape`. Class ini punya satu properti: `name`.

```javascript
class Shape {
  constructor(name) {
    this.name = name;
  }
}
```

Ini adalah "blueprint" dasar. Semua shape (bentuk) pasti punya nama, jadi kita taruh di sini.

---

<a name="subclass-extends"></a>
## ğŸ§© Subclass dengan `extends`

Nah, sekarang kita buat class `Rectangle` yang **mewarisi** dari `Shape`. Caranya pakai keyword `extends`.

```javascript
class Rectangle extends Shape {
  constructor(name, width, height) {
    super(name); // â† memanggil constructor Shape

    this.width = width;
    this.height = height;
  }
}
```

- `Rectangle extends Shape` â†’ artinya Rectangle adalah **subclass** (class anak) dari Shape
- Rectangle punya properti tambahan: `width` dan `height`
- `name` tetap diurus oleh Shape (parent-nya)

Contoh pakai:

```javascript
const rect = new Rectangle('Rect 1', 20, 20);
console.log(rect);
// Output: Rectangle { name: 'Rect 1', width: 20, height: 20 }
```

---

<a name="keyword-super"></a>
## ğŸ”‘ Keyword `super`

Ini bagian yang paling penting! Kapanpun kamu pakai `extends`, **wajib panggil `super()`** di dalam constructor subclass.

```javascript
super(name); // memanggil constructor dari parent class (Shape)
```

`super(name)` itu artinya: *"Hei Shape, tolong jalankan constructor-mu dengan nilai `name` ini."*

Jadi `this.name = name` yang ada di `Shape` tetap dieksekusi, tanpa kita perlu nulis ulang di `Rectangle`.

> âš ï¸ **Ingat:** Panggil `super()` sebelum mengakses `this` di subclass, kalau tidak JavaScript akan error.

---

<a name="method-parent"></a>
## ğŸ› ï¸ Method di Parent Class

Kita bisa tambahkan method di parent class, dan **semua subclass otomatis bisa pakai** method itu.

```javascript
class Shape {
  constructor(name) {
    this.name = name;
  }

  logName() {
    console.log('Shape Name: ' + this.name);
  }
}
```

Sekarang `rect.logName()` langsung jalan meski method-nya ada di `Shape`, bukan di `Rectangle`:

```javascript
rect.logName();
// Output: Shape Name: Rect 1
```

Ini bisa terjadi karena JavaScript mencari method lewat **prototype chain** â€” pertama cek di `Rectangle`, kalau tidak ada, lanjut cek ke `Shape`, kalau tidak ada lagi, lanjut ke `Object`.

---

<a name="polymorphism"></a>
## ğŸ­ Polymorphism â€” Override Method

Kita juga bisa **menimpa (override)** method dari parent class di subclass. Ini yang disebut **polymorphism**.

Contoh: kita buat class `Circle` yang punya `logName()` versinya sendiri.

```javascript
class Circle extends Shape {
  constructor(name, radius) {
    super(name);
    this.radius = radius;
  }

  // Override logName() dari Shape
  logName() {
    console.log('Circle Name: ' + this.name);
  }
}
```

```javascript
const cir = new Circle('Cir 1', 30);
cir.logName();
// Output: Circle Name: Cir 1  â† pakai versi Circle, bukan Shape
```

Sedangkan `rect.logName()` tetap pakai versi `Shape` karena `Rectangle` tidak punya override:

```javascript
rect.logName();
// Output: Shape Name: Rect 1  â† pakai versi Shape
```

> ğŸ’¡ Jadi tiap class bisa punya perilaku yang *berbeda* untuk method dengan nama yang *sama*. Itulah polymorphism.

---

<a name="instanceof"></a>
## ğŸ” `instanceof`

Karena `Rectangle` adalah subclass dari `Shape`, maka sebuah `rect` itu dianggap **instance dari keduanya**.

```javascript
console.log(rect instanceof Rectangle); // true
console.log(rect instanceof Shape);     // true
```

Masuk akal kan? Sebuah rectangle *memang* adalah sebuah shape. Hubungan ini terbentuk otomatis karena kita pakai `extends`.

---

<a name="kode-lengkap"></a>
## ğŸ“„ Kode Lengkap

```javascript
// Parent class
class Shape {
  constructor(name) {
    this.name = name;
  }

  logName() {
    console.log('Shape Name: ' + this.name);
  }
}

// Rectangle - Subclass
class Rectangle extends Shape {
  constructor(name, width, height) {
    super(name);

    this.width = width;
    this.height = height;
  }
}

// Circle - Subclass
class Circle extends Shape {
  constructor(name, radius) {
    super(name);

    this.radius = radius;
  }

  // Override logName() dari Shape (polymorphism)
  logName() {
    console.log('Circle Name: ' + this.name);
  }
}

const rect = new Rectangle('Rect 1', 20, 20);
console.log(rect);
rect.logName(); // Shape Name: Rect 1

const cir = new Circle('Cir 1', 30);
cir.logName(); // Circle Name: Cir 1

// rect adalah instance dari Rectangle sekaligus Shape
console.log(rect instanceof Rectangle); // true
console.log(rect instanceof Shape);     // true
```

---

## ğŸ—‚ï¸ Ringkasan Konsep

| Konsep | Penjelasan Singkat |
|---|---|
| `extends` | Membuat subclass yang mewarisi parent class |
| `super()` | Memanggil constructor parent class |
| Method inheritance | Subclass otomatis bisa pakai method parent |
| Override / Polymorphism | Subclass bisa punya versi method sendiri |
| `instanceof` | Cek apakah objek adalah instance dari class tertentu |
