# ğŸ” Getters & Setters di JavaScript (Classes)

> Dokumentasi belajar ini dibuat dari video tutorial JavaScript tentang getters dan setters menggunakan class.

---

## ğŸ“‘ Daftar Isi

- ğŸ¯ [Apa Itu Getters & Setters?](#apa-itu-getters--setters)
- ğŸ—ï¸ [Membuat Class Person](#membuat-class-person)
- ğŸ”‘ [Underscore â€” Konvensi Private Property](#underscore--konvensi-private-property)
- ğŸ‘€ [Getter â€” Mengambil Nilai dengan Transformasi](#getter--mengambil-nilai-dengan-transformasi)
- âœï¸ [Setter â€” Mengatur Nilai dengan Validasi](#setter--mengatur-nilai-dengan-validasi)
- ğŸ§¹ [Refactor: Hindari Pengulangan Kode](#refactor-hindari-pengulangan-kode)
- ğŸ”— [Getter Computed â€” fullName](#getter-computed--fullname)
- ğŸ“‹ [Kode Lengkap](#kode-lengkap)

---

<a name="apa-itu-getters--setters"></a>
## ğŸ¯ Apa Itu Getters & Setters?

Getters dan setters adalah **method khusus** yang digunakan untuk mengambil (*get*) atau mengatur (*set*) nilai properti dari sebuah object. Meskipun bentuknya method, cara memanggilnya seperti properti biasa â€” tanpa tanda kurung `()`.

Ada beberapa alasan kenapa kita pakai getters dan setters dibanding langsung akses propertinya:

- **Transformasi nilai** â€” misalnya selalu memastikan nama dimulai dengan huruf kapital
- **Properti private** â€” kita bisa "menyembunyikan" properti aslinya supaya tidak diakses sembarangan
- **Logika tambahan saat set** â€” misalnya validasi input sebelum disimpan

> Getters dan setters bisa dipakai di **class**, **constructor function**, dan **object literal**. Di dokumentasi ini kita fokus ke **class** dulu.

---

<a name="membuat-class-person"></a>
## ğŸ—ï¸ Membuat Class Person

Kita mulai dengan membuat class `Person` yang punya dua properti: `firstName` dan `lastName`.

```javascript
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
}

const person1 = new Person('john', 'doe');
console.log(person1.firstName); // john
```

ğŸ’¡ **Apa yang terjadi di sini?**
- `constructor` dipanggil otomatis saat kita buat object baru dengan `new Person(...)`
- `this.firstName` dan `this.lastName` menyimpan nilai yang dikirim masuk
- Saat ini kita bisa langsung akses `person1.firstName` â€” hasilnya `john` dengan huruf kecil

Masalahnya: bagaimana kalau kita selalu mau nama dimulai dengan huruf kapital, meskipun inputnya huruf kecil? Di sinilah getter berguna!

---

<a name="underscore--konvensi-private-property"></a>
## ğŸ”‘ Underscore â€” Konvensi Private Property

Sebelum bikin getter, ada satu hal penting yang perlu dipahami. Kalau nama properti dan nama getter sama persis, akan terjadi **rekursi tak terbatas** (error!). Solusinya: kasih **underscore `_`** di depan nama properti aslinya.

```javascript
class Person {
  constructor(firstName, lastName) {
    this._firstName = firstName; // â† pakai underscore
    this._lastName = lastName;   // â† pakai underscore
  }
}
```

ğŸ’¡ **Apa yang terjadi di sini?**
- `_firstName` adalah konvensi yang dipakai developer untuk menandai bahwa properti ini **seharusnya tidak diakses langsung dari luar**
- Ini bukan proteksi sungguhan â€” `person1._firstName` masih bisa diakses â€” tapi ini **perjanjian tidak tertulis** antar developer bahwa "jangan akses ini langsung"
- Dengan pakai `_firstName` untuk propertinya, kita bisa pakai nama `firstName` (tanpa underscore) untuk getternya

---

<a name="getter--mengambil-nilai-dengan-transformasi"></a>
## ğŸ‘€ Getter â€” Mengambil Nilai dengan Transformasi

Getter dibuat dengan keyword `get` sebelum nama method-nya. Kita bisa tambahkan logika di dalamnya, misalnya membuat huruf pertama kapital.

**Langkah 1 â€” Getter sederhana yang hanya mengembalikan nilai:**

```javascript
class Person {
  constructor(firstName, lastName) {
    this._firstName = firstName;
    this._lastName = lastName;
  }

  get firstName() {
    return this._firstName; // hanya mengembalikan nilainya saja
  }
}

const person1 = new Person('john', 'doe');
console.log(person1.firstName); // john  â† masih lowercase
```

**Langkah 2 â€” Getter dengan transformasi kapital:**

```javascript
class Person {
  constructor(firstName, lastName) {
    this._firstName = firstName;
    this._lastName = lastName;
  }

  get firstName() {
    return this._firstName.charAt(0).toUpperCase() + this._firstName.slice(1);
    //     â†‘ ambil huruf pertama    â†‘ jadikan kapital  â†‘ sambung sisa huruf
  }
}

const person1 = new Person('john', 'doe');
console.log(person1.firstName); // John  â† huruf pertama kapital!
```

ğŸ’¡ **Apa yang terjadi di sini?**
- `get firstName()` â†’ ini getter, dipanggil seperti properti: `person1.firstName` (bukan `person1.firstName()`)
- `charAt(0)` â†’ mengambil karakter pertama dari string, yaitu `'j'`
- `.toUpperCase()` â†’ mengubahnya jadi `'J'`
- `.slice(1)` â†’ mengambil semua karakter mulai index 1 (sisanya: `'ohn'`)
- Hasil akhir: `'J' + 'ohn'` = `'John'` âœ…

---

<a name="setter--mengatur-nilai-dengan-validasi"></a>
## âœï¸ Setter â€” Mengatur Nilai dengan Validasi

Setter dibuat dengan keyword `set`. Setter **selalu menerima satu parameter** â€” yaitu nilai baru yang ingin kita simpan. Di dalam setter, kita bisa tambahkan logika sebelum nilai disimpan.

```javascript
class Person {
  constructor(firstName, lastName) {
    this._firstName = firstName;
    this._lastName = lastName;
  }

  get firstName() {
    return this._firstName.charAt(0).toUpperCase() + this._firstName.slice(1);
  }

  set firstName(value) {
    // simpan ke _firstName dengan huruf pertama kapital
    this._firstName = value.charAt(0).toUpperCase() + value.slice(1);
  }
}

const person1 = new Person('john', 'doe');

// Menggunakan setter â€” seperti assignment biasa
person1.firstName = 'joe'; // â† ini memanggil setter, bukan langsung set properti

console.log(person1); // _firstName: 'Joe'  â† huruf pertama kapital!
```

ğŸ’¡ **Apa yang terjadi di sini?**
- `set firstName(value)` â†’ ini setter, dipanggil saat kita assign: `person1.firstName = 'joe'`
- `value` adalah nilai yang kita kirim, yaitu `'joe'`
- Di dalam setter, nilai dikapitalisasi dulu sebelum disimpan ke `this._firstName`
- Hasilnya `_firstName` berisi `'Joe'`, bukan `'joe'`

---

<a name="refactor-hindari-pengulangan-kode"></a>
## ğŸ§¹ Refactor: Hindari Pengulangan Kode

Kalau kita buat getter dan setter untuk `lastName` juga, logika kapitalisasi akan **diulang berkali-kali**. Solusinya: buat satu method helper `capitalizeFirst()` di dalam class.

```javascript
class Person {
  constructor(firstName, lastName) {
    this._firstName = firstName;
    this._lastName = lastName;
  }

  // âœ¨ Method helper â€” dipanggil oleh getter & setter
  capitalizeFirst(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }

  get firstName() {
    return this.capitalizeFirst(this._firstName); // pakai method helper
  }

  set firstName(value) {
    this._firstName = this.capitalizeFirst(value); // pakai method helper
  }

  get lastName() {
    return this.capitalizeFirst(this._lastName);
  }

  set lastName(value) {
    this._lastName = this.capitalizeFirst(value);
  }
}

const person1 = new Person('john', 'doe');
console.log(person1.firstName); // John
console.log(person1.lastName);  // Doe

person1.lastName = 'smith';
console.log(person1.lastName);  // Smith
```

ğŸ’¡ **Apa yang terjadi di sini?**
- `capitalizeFirst(value)` adalah method biasa di dalam class yang bertugas mengkapitalisasi
- Karena method ini ada di dalam class yang sama, kita akses dengan `this.capitalizeFirst(...)`
- Sekarang logika kapitalisasi cukup ditulis **satu kali** saja, dan dipakai di mana-mana

---

<a name="getter-computed--fullname"></a>
## ğŸ”— Getter Computed â€” fullName

Getter tidak hanya berguna untuk transformasi nilai â€” bisa juga dipakai untuk **menggabungkan beberapa properti** menjadi satu nilai baru. Contohnya `fullName`:

```javascript
class Person {
  // ... constructor, capitalizeFirst, getter/setter firstName & lastName

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
    //        â†‘ memanggil getter firstName   â†‘ memanggil getter lastName
  }
}

const person1 = new Person('john', 'doe');
person1.firstName = 'joe';
person1.lastName = 'smith';

console.log(person1.fullName); // Joe Smith
```

ğŸ’¡ **Apa yang terjadi di sini?**
- `get fullName()` menggabungkan `this.firstName` dan `this.lastName` menggunakan template literal (backtick)
- `this.firstName` di sini **memanggil getter** `firstName`, bukan properti `_firstName` langsung
- Jadi nilai yang dikembalikan sudah otomatis terkapitalisasi
- `fullName` tidak disimpan sebagai properti di object â€” ini adalah **computed value** yang dihitung saat dipanggil
- Kita bisa lihat getter/setter di bagian **prototype** object (bukan di properti langsung)

---

<a name="kode-lengkap"></a>
## ğŸ“‹ Kode Lengkap

```javascript
class Person {
  constructor(firstName, lastName) {
    this._firstName = firstName;
    this._lastName = lastName;
  }

  get firstName() {
    return this.capitalizeFirst(this._firstName);
  }

  set firstName(value) {
    this._firstName = this.capitalizeFirst(value);
  }

  get lastName() {
    return this.capitalizeFirst(this._lastName);
  }

  set lastName(value) {
    this._lastName = this.capitalizeFirst(value);
  }

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  capitalizeFirst(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
}

const person1 = new Person('john', 'doe');
console.log(person1.firstName); // John
console.log(person1.lastName);  // Doe

person1.firstName = 'joe';
person1.lastName = 'smith';
console.log(person1.fullName);  // Joe Smith
console.log(person1);           // Person { _firstName: 'Joe', _lastName: 'Smith' }
```

---

> âš ï¸ **Catatan:** Di video ini hanya dibahas getters & setters dengan **class**. Di video berikutnya akan dibahas cara penggunaannya dengan **constructor function** dan **object literal**.
